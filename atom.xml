<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>loveofpeach&#39;s</title>
  
  <subtitle>tree hole</subtitle>
  <link href="https://loveofpeach.github.io/atom.xml" rel="self"/>
  
  <link href="https://loveofpeach.github.io/"/>
  <updated>2023-01-24T03:10:22.461Z</updated>
  <id>https://loveofpeach.github.io/</id>
  
  <author>
    <name>love of peach</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>产假问题想到的</title>
    <link href="https://loveofpeach.github.io/posts/2cbce842.html"/>
    <id>https://loveofpeach.github.io/posts/2cbce842.html</id>
    <published>2023-01-23T09:58:08.000Z</published>
    <updated>2023-01-24T03:10:22.461Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文章尚未完成，只是草稿</strong></p><p>在我所学的无法在现代社会中掌握专业技能的专业的某门专业课上，我曾想过一种设计，一种尝试解决产假问题的机制。虽然它在后来被我否定，。。。出于自身的原因见识狭隘，想要思考社会问题恐怕必须增长自己的见识，取看看其他先进国家的成功经验，不能沉溺于无用的空想，而我囿于种种原因，…。但我还是想留下思考它的过程。它虽然是不成熟、欠考虑，甚至是幼稚的，但它反映了我思想的一些变化。。。</p><p>毕竟，It’s a tree hole, I’m free.</p><p>题目：现代企业的产假管理（暂定）</p><p>简述：在电力市场概论这门课中我了解到『pool』的概念，我想将这个概念运用到产假管理的方面。人们在休产假前，可通过为同单位的在休人员分担工作，积累额外工作天数，这个天数在需要休产假时可以取出。它的目标是促进两性就业机会的平等并为年轻家庭的生育提供保障。</p><p>以下是暂时想到的：</p><ol><li>个人在pool中积累的天数由社会公共机构把持，不随工作变更清空。</li><li>取出天数休产假时，由男女双方的数据计算总天数。为促进两性平等的就业机会、保障家庭的生育过程，男方也休产假（尽管天数未必相等）。</li><li>为防止就业时的歧视，该天数在正式录用前对招聘单位不可见。</li><li>若将在休人员的工作划分为不同模块由不同人员分担，需要设计额外工作天数的计算方法。</li><li>可以提前预支天数，但在产假后需在一定时期内偿完。该措施为不同选择的人群提供更加人性化的休假方式。</li></ol><p>论文会结合工商管理所学的知识，例如人力资源等等，作具体的、既有定性又有定量的分析。</p><hr><p>而这反映出一种透着穷酸气的实用主义，打个未必恰当的比方，就好比只会用功不知休息的学生一样。这种可怕的实用主义正充斥中国社会的各个角落。</p><p>承认人类的不理性才是最大的理性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;文章尚未完成，只是草稿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我所学的无法在现代社会中掌握专业技能的专业的某门专业课上，我曾想过一种设计，一种尝试解决产假问题的机制。虽然它在后来被我否定，。。。出于自身的原因见识狭隘，想要思考社会问题恐怕必须增长自己的见识，取看</summary>
      
    
    
    
    <category term="观点" scheme="https://loveofpeach.github.io/categories/%E8%A7%82%E7%82%B9/"/>
    
    
    <category term="想法" scheme="https://loveofpeach.github.io/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BOI2009 Radio Transmission</title>
    <link href="https://loveofpeach.github.io/posts/ac682fe9.html"/>
    <id>https://loveofpeach.github.io/posts/ac682fe9.html</id>
    <published>2023-01-22T14:49:40.000Z</published>
    <updated>2023-01-23T09:58:56.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的。但是字符串 $s_2$ 是不确定的，现在只想知道它的最短长度是多少。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $L$，表示给出字符串的长度。 </p><p>第二行给出字符串 $s_1$ 的一个子串，全由小写字母组成。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，表示 $s_2$ 的最短长度。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">cabcabca</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h3 id="样例输入输出-1-解释"><a href="#样例输入输出-1-解释" class="headerlink" title="样例输入输出 1 解释"></a>样例输入输出 1 解释</h3><p>对于样例，我们可以利用 $\texttt{abc}$ 不断自我连接得到 $\texttt{abcabcabc}$，读入的 $\texttt{cabcabca}$，是它的子串。</p><h3 id="规模与约定"><a href="#规模与约定" class="headerlink" title="规模与约定"></a>规模与约定</h3><p>对于全部的测试点，保证 $1 &lt; L \le 10^6$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>以后再说</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的。但是字符串 $s_2$ 是不确定的，现在只想知</summary>
      
    
    
    
    <category term="做题" scheme="https://loveofpeach.github.io/categories/%E5%81%9A%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://loveofpeach.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo踩坑记录</title>
    <link href="https://loveofpeach.github.io/posts/2b780dd.html"/>
    <id>https://loveofpeach.github.io/posts/2b780dd.html</id>
    <published>2023-01-14T04:49:42.000Z</published>
    <updated>2023-01-16T02:04:44.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="live2d和aplayer"><a href="#live2d和aplayer" class="headerlink" title="live2d和aplayer"></a>live2d和aplayer</h2><p>有时加载会很慢或者无法加载，这可能只是live2d和aplayer自身的问题。尤其是aplayer，偶尔会有几天在任何设备上都无法加载（我只遇到过一次）。</p><p>注意如果要使用网易的服务，要写成<code>data-server=&quot;netease&quot;</code>，我这里因为不知道网易的英文名试了半天 -_-#</p><h2 id="Gitalk加载失败"><a href="#Gitalk加载失败" class="headerlink" title="Gitalk加载失败"></a>Gitalk加载失败</h2><p>Gitalk配置完成之后，仍有可能无法加载。这是因为其部分服务在墙外，需要翻墙访问文章页面以创建issue。之后即使不翻墙也可正常显示。</p><h2 id="MathJax渲染失败"><a href="#MathJax渲染失败" class="headerlink" title="MathJax渲染失败"></a>MathJax渲染失败</h2><p>Hexo默认使用<code>hexo-renderer-marked</code>引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，会产生语义冲突。</p><p>解决方案：更换Hexo的markdown渲染引擎。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>接下来到博客根目录下，找到<code>node_modules\kramed\lib\rules\inline.js</code>，把第11行的escape变量的值做相应的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/</span><br></pre></td></tr></table></figure><p>同时把第20行的em变量也要做相应的修改:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span><br></pre></td></tr></table></figure><p>重新启动hexo即可。</p><h2 id="代码缩进混乱"><a href="#代码缩进混乱" class="headerlink" title="代码缩进混乱"></a>代码缩进混乱</h2><p>这是tab缩进的问题。</p><p>找到站点配置文件中<code>tab_replace</code>，设置<code>tab_replace: &#39;    &#39;</code>（4个空格）即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;live2d和aplayer&quot;&gt;&lt;a href=&quot;#live2d和aplayer&quot; class=&quot;headerlink&quot; title=&quot;live2d和aplayer&quot;&gt;&lt;/a&gt;live2d和aplayer&lt;/h2&gt;&lt;p&gt;有时加载会很慢或者无法加载，这可能只是liv</summary>
      
    
    
    
    <category term="杂" scheme="https://loveofpeach.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="hexo" scheme="https://loveofpeach.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理笔记</title>
    <link href="https://loveofpeach.github.io/posts/aae04aa8.html"/>
    <id>https://loveofpeach.github.io/posts/aae04aa8.html</id>
    <published>2023-01-12T14:27:45.000Z</published>
    <updated>2023-01-22T14:46:39.615Z</updated>
    
    <content type="html"><![CDATA[<p>以后填坑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以后填坑。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="笔记" scheme="https://loveofpeach.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="https://loveofpeach.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>蓝色笔记</title>
    <link href="https://loveofpeach.github.io/posts/6bc19761.html"/>
    <id>https://loveofpeach.github.io/posts/6bc19761.html</id>
    <published>2023-01-04T13:25:45.000Z</published>
    <updated>2023-01-22T14:46:01.686Z</updated>
    
    <content type="html"><![CDATA[<p>考研的原因：</p><p><img src="https://bu.dusays.com/2023/01/04/63b5789893aa1.png" alt="考研只为慢就业"></p><p>个人笔记，存档。</p><p><img src="https://bu.dusays.com/2023/01/05/63b653bf90fe1.jpg" alt="考研蓝色笔记-01.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f41fdac.jpg" alt="考研蓝色笔记-02.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f4c52fd.jpg" alt="考研蓝色笔记-03.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f5a5e7d.jpg" alt="考研蓝色笔记-04.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f59d4ef.jpg" alt="考研蓝色笔记-05.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f604ef0.jpg" alt="考研蓝色笔记-06.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f5ca516.jpg" alt="考研蓝色笔记-07.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f5bb43f.jpg" alt="考研蓝色笔记-08.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f549d93.jpg" alt="考研蓝色笔记-09.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b653f610a7d.jpg" alt="考研蓝色笔记-10.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b654441c8b6.jpg" alt="考研蓝色笔记-11.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b6544426434.jpg" alt="考研蓝色笔记-12.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b65446b0048.jpg" alt="考研蓝色笔记-13.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b65447d50f3.jpg" alt="考研蓝色笔记-14.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b65448c282d.jpg" alt="考研蓝色笔记-15.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b6544a50fb2.jpg" alt="考研蓝色笔记-16.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b6544a50fb2.jpg" alt="考研蓝色笔记-17.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b65449a3b41.jpg" alt="考研蓝色笔记-18.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b65449ad4b4.jpg" alt="考研蓝色笔记-19.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b6544a5e7ee.jpg" alt="考研蓝色笔记-20.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b6549f445d5.jpg" alt="考研蓝色笔记-21.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b6549d6a227.jpg" alt="考研蓝色笔记-22.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b6549f6c73b.jpg" alt="考研蓝色笔记-23.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b654a02f503.jpg" alt="考研蓝色笔记-24.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b654a0b3468.jpg" alt="考研蓝色笔记-25.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b654a027760.jpg" alt="考研蓝色笔记-26.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b654a0e1d2d.jpg" alt="考研蓝色笔记-27.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b6549e9b427.jpg" alt="考研蓝色笔记-28.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b654a1e322e.jpg" alt="考研蓝色笔记-29.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b654a19b2d5.jpg" alt="考研蓝色笔记-30.jpg"></p><p><img src="https://bu.dusays.com/2023/01/05/63b654ee3f9b8.jpg" alt="考研蓝色笔记-31.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;考研的原因：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bu.dusays.com/2023/01/04/63b5789893aa1.png&quot; alt=&quot;考研只为慢就业&quot;&gt;&lt;/p&gt;
&lt;p&gt;个人笔记，存档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bu.du</summary>
      
    
    
    
    <category term="笔记" scheme="https://loveofpeach.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://loveofpeach.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="慢就业" scheme="https://loveofpeach.github.io/tags/%E6%85%A2%E5%B0%B1%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>数学错题集</title>
    <link href="https://loveofpeach.github.io/posts/a731e7f0.html"/>
    <id>https://loveofpeach.github.io/posts/a731e7f0.html</id>
    <published>2023-01-04T12:51:31.000Z</published>
    <updated>2023-01-22T14:45:05.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多元函数微分学"><a href="#多元函数微分学" class="headerlink" title="多元函数微分学"></a>多元函数微分学</h2><p><img src="https://bu.dusays.com/2023/01/04/63b5799722887.jpg" alt="数学错题集-01.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57995ec2b5.jpg" alt="数学错题集-02.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57990c09f3.jpg" alt="数学错题集-03.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b5799429574.jpg" alt="数学错题集-04.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57998a1afc.jpg" alt="数学错题集-05.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b5799984587.jpg" alt="数学错题集-06.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b579925e8f3.jpg" alt="数学错题集-07.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57993ecde2.jpg" alt="数学错题集-08.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b5799341f85.jpg" alt="数学错题集-09.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b5799914d57.jpg" alt="数学错题集-10.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57aa92d944.jpg" alt="数学错题集-11.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57aa968384.jpg" alt="数学错题集-12.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57aaab8d66.jpg" alt="数学错题集-13.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57aaa3c26f.jpg" alt="数学错题集-14.jpg"></p><h2 id="极值"><a href="#极值" class="headerlink" title="极值"></a>极值</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57aa778d11.jpg" alt="数学错题集-15.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57aa9d91a8.jpg" alt="数学错题集-16.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57aa897966.jpg" alt="数学错题集-17.jpg"></p><h2 id="积分与极限"><a href="#积分与极限" class="headerlink" title="积分与极限"></a>积分与极限</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57aa22c1de.jpg" alt="数学错题集-18.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57aa8b882f.jpg" alt="数学错题集-19.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57aa7ab852.jpg" alt="数学错题集-20.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b190d605.jpg" alt="数学错题集-21.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b1796e5e.jpg" alt="数学错题集-22.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b183ddde.jpg" alt="数学错题集-23.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b21d0358.jpg" alt="数学错题集-24.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b20698dd.jpg" alt="数学错题集-25.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b2116299.jpg" alt="数学错题集-26.jpg"></p><h2 id="一元函数"><a href="#一元函数" class="headerlink" title="一元函数"></a>一元函数</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57b1eb564b.jpg" alt="数学错题集-27.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b200004e.jpg" alt="数学错题集-28.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b1f6d84c.jpg" alt="数学错题集-29.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b1f76647.jpg" alt="数学错题集-30.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b9059203.jpg" alt="数学错题集-31.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b8fde903.jpg" alt="数学错题集-32.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b94a0f86.jpg" alt="数学错题集-33.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b955dabf.jpg" alt="数学错题集-34.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b94151f2.jpg" alt="数学错题集-35.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b98c1752.jpg" alt="数学错题集-36.jpg"></p><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57b983feaa.jpg" alt="数学错题集-37.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b97eea10.jpg" alt="数学错题集-38.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57b98c7d1a.jpg" alt="数学错题集-39.jpg"></p><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57b98dd08b.jpg" alt="数学错题集-40.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c018d404.jpg" alt="数学错题集-41.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57bff85b9e.jpg" alt="数学错题集-42.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c000837f.jpg" alt="数学错题集-43.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c04ec643.jpg" alt="数学错题集-44.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c04f36f2.jpg" alt="数学错题集-45.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c04424fd.jpg" alt="数学错题集-46.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c046d6d8.jpg" alt="数学错题集-47.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c046a2bb.jpg" alt="数学错题集-48.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c04e666f.jpg" alt="数学错题集-49.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c04e951a.jpg" alt="数学错题集-50.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c6da5b3a.jpg" alt="数学错题集-51.jpg"></p><h2 id="2022数二"><a href="#2022数二" class="headerlink" title="2022数二"></a>2022数二</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57c70289c4.jpg" alt="数学错题集-52.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c6ec3006.jpg" alt="数学错题集-53.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c71bbdf8.jpg" alt="数学错题集-54.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c7261dd7.jpg" alt="数学错题集-55.jpg"></p><h2 id="2020数二"><a href="#2020数二" class="headerlink" title="2020数二"></a>2020数二</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57c720d789.jpg" alt="数学错题集-56.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c7259a69.jpg" alt="数学错题集-57.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c721e84f.jpg" alt="数学错题集-58.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c71f19b9.jpg" alt="数学错题集-59.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57c6feba9d.jpg" alt="数学错题集-60.jpg"></p><h2 id="2019数二"><a href="#2019数二" class="headerlink" title="2019数二"></a>2019数二</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57cef090a9.jpg" alt="数学错题集-61.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57cef07015.jpg" alt="数学错题集-62.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57cefe52a9.jpg" alt="数学错题集-63.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57cf0d4784.jpg" alt="数学错题集-64.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57cf154d21.jpg" alt="数学错题集-65.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57cf07c19b.jpg" alt="数学错题集-66.jpg"></p><h2 id="2018数二"><a href="#2018数二" class="headerlink" title="2018数二"></a>2018数二</h2><p><img src="https://bu.dusays.com/2023/01/04/63b57cf18e05d.jpg" alt="数学错题集-67.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57cf13d8e0.jpg" alt="数学错题集-68.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57cf176324.jpg" alt="数学错题集-69.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57cf1879eb.jpg" alt="数学错题集-70.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57d76908cf.jpg" alt="数学错题集-71.jpg"></p><p><img src="https://bu.dusays.com/2023/01/04/63b57d76a5afe.jpg" alt="数学错题集-72.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多元函数微分学&quot;&gt;&lt;a href=&quot;#多元函数微分学&quot; class=&quot;headerlink&quot; title=&quot;多元函数微分学&quot;&gt;&lt;/a&gt;多元函数微分学&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://bu.dusays.com/2023/01/04/63b5799</summary>
      
    
    
    
    <category term="做题" scheme="https://loveofpeach.github.io/categories/%E5%81%9A%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://loveofpeach.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="慢就业" scheme="https://loveofpeach.github.io/tags/%E6%85%A2%E5%B0%B1%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>信与回信</title>
    <link href="https://loveofpeach.github.io/posts/d1e8cada.html"/>
    <id>https://loveofpeach.github.io/posts/d1e8cada.html</id>
    <published>2022-12-28T04:33:57.000Z</published>
    <updated>2023-01-01T14:31:28.175Z</updated>
    
    <content type="html"><![CDATA[<p>可以看作是《春宵苦短，少女前进吧》的后续。</p><blockquote><p>原文：<a href="https://movie.douban.com/review/8521843/">https://movie.douban.com/review/8521843/</a><br>作者：豆瓣用户 一切顺利！</p></blockquote><p><img src="https://bu.dusays.com/2023/01/01/63b198d0d1c47.png" alt="20-3v2.png" title="电影中的进进堂"></p><h2 id="【剧场特典】给“乙女”的信（渣翻）"><a href="#【剧场特典】给“乙女”的信（渣翻）" class="headerlink" title="【剧场特典】给“乙女”的信（渣翻）"></a>【剧场特典】给“乙女”的信（渣翻）</h2><p>拜启。</p><p>问候并祝安康。</p><p>此前能够同往“进进堂”及旧书店，我感到非常欣喜。</p><p>当时怀着邀请你就不能有不周到的想法，心情也变得紧张。但在和你交谈这一年的回忆时，渐渐变得平稳，就像是肚子上顶着刚出锅的肉包子舒服躺下般的惬意。上次有这么美好的感觉，大概是婴儿时初次洗澡的事吧。再次表达谢意。</p><p>不过最近也实在是寒冷呀。为了和无情的寒冷对抗，现在的我正钻在四叠半宿舍的被窝里写下这封信。请原谅这随意的行为。在这连叹气都能冻结住的四叠半内，一切脑力活动不得不在完成在从来都是摊开的被窝上，我强撑着这种严酷生活。</p><p>话说回来，写这封信的理由有两个。</p><p>第一个理由，我仅仅是想要试着给你写信。如果你觉得困扰，今后罢手。</p><p>还有一个是，之前见面的时候忘记约定下次的碰面。实在是大意了。如果你没有觉得“真是受够了”的话，可以再次一起做些什么吗？</p><p>关于应该一起去哪里，请允许我说明一个提案。</p><p>要讲述这个像天启一般进入我脑内的提案，就得从前些日子我和樋口一起去北白川天神宫说起。</p><p>那天早上开始下起雪，东边的群山像撒了层砂糖似的变得洁白。这种天气当然再适合不过读书。我便在宿舍里大口吃着肉馒头熟读玩味康德的《纯粹理性批判》。正用纯粹的心情批判自己理性的时候，樋口穿着落满雪花的夹克突然来了。</p><p>“呀，你。我能拜托件事儿吗？”</p><p>从樋口氏处得知，洛中有个“狸猫文学赏”，似乎会挑选每年写就的狸猫小说中最优一作来进行表彰。“那是什么呀”我还是无法想象。而且再继续听下去，樋口根本连小说都没写过，却由于“常年过着狸猫般生活之事的功绩”而得得到了文学赏的荣誉奖。真是充满狸猫气息的可疑，再加上授奖式还是在东山山麓北白川天神宫内举行这点，愈发令人怀疑。这种《漫画日本昔话》一样的文学赏真的存在吗？毕竟樋口一直就是故弄玄虚的好手。</p><p>“但是说是狸猫，樋口更该是天狗吧。”</p><p>“天狗啦狸猫啦都是同样的呦。不管得到的是马粪还是柿子的茎叶，我是能得到好主义。听说有奖品可以拿，来帮忙搬运吧。”就这样，我们在雪天出门了。</p><p>走在通向北白川天神宫志贺越道上，我就“男女间合适的幽会”一事向樋口请教。不过是想向可以信任的前辈问些一般论的东西罢了。于是樋口给我讲述了“与画中女性梦中相会之术”和“与看不见的恋人互通书信之术”之类的事情。但这些事情对现在的我来说完全没用，只觉得一头雾水。</p><p>听我“想听些更加平凡的方法”之后，樋口唰啦唰啦摸着胡子发出“唔—”的声音。</p><p>“……平凡的东西一点也不了解。”</p><p>向樋口寻求一般论的我真是笨蛋。</p><p>“一牵扯到实际利益就没辙了呀。”</p><p>“喂喂，你的奉承话就免了吧。”</p><p>终于到达北白川天神宫的我们，走过架设在白川上的小桥，穿过阴暗的树林登上了石制台阶。但是周围完全没有举办授奖式的迹象。当我觉得肯定是被谁戏弄之时，樋口突然小声说了句“是柑橘呀”。</p><p>在拜殿后方，我终于发现了满满一纸箱的柑橘。上边还用修行僧人用的法螺压着一张草纸，写着拙劣的“之后的事就交给你了”。</p><p>“你看，很豪气吧！”</p><p>“……这真的是奖品吗？明明是授奖式却谁也不在。简直像是被狸猫骗了。”</p><p>“所以说是自助的形式吧。”</p><p>尽管仍旧半信半疑，我们还是遵从写着“之后的事就交给你了”的草纸，严肃地完成授奖式。然后带着可疑的蜜柑开始返回。搬运大量蜜柑显而易见是我的任务，樋口只负责走在前边随意地吹着法螺。在降雪的东山里，回响出说不上是舒畅还是悲伤的声音。</p><p>说起在“进进堂”共饮咖啡。这旁人看来小小的一步对我们来讲确实是巨大的一步。已经往新世界踏出第一步的当下，犹豫是不会带来进步的。我们应当趁此鼓起勇气向前迈步。但是呀，下一步应该怎么做呢？即使用被《纯粹理性批判》锤炼的理性，我也找不到合适的方案。这是什么缘故呢？</p><p>在白川桥上夸张地跌倒，大概就是因为深陷这些想法而没注意脚下吧。从整个跌落的纸箱里蜜柑咕噜咕噜地滚落出来。滚落出的蜜柑中有一个喊着“老子就从这启程了”纵身跃下川流。只顾着慌慌张张收集其他蜜柑，对落下白川的那个家伙只能放弃。樋口则透过栏杆一边眺望着河面，一边吹起法螺，发出了有些悲伤的响声。</p><p>“嘛别失落呀，你，” 樋口说道，“说不定在不知何处它会被美丽的少女捡到呢。”</p><p>无论如何这种事也是不可能的吧，可能是自己使它掉落的罪恶感使然，我不由得为那颗小小圆圆蜜柑的幸福祈祷起来。小小的圆圆的，又使我联想起你来，我变得更加同情那颗蜜柑。</p><p>正要再次出发的时候，小巧洁白又软乎乎的东西从灰色天空降下。开始还以为是雪花，但是它们粘在肩膀上并没有融化。仔细看发现，那是可爱的羽毛。这东西是从哪里飞来的呢。用手指拈起向着远处，太阳的光线穿透云彩的缝隙染得羽毛银光闪闪。不知为何感到扔掉的话太过可惜，就在我把羽毛收进口袋的瞬间，脑内冷不丁地浮现出“银幕”这个词语。</p><p>银幕。银幕。银幕的冒险！</p><p>银幕的冒险，正是指明去往电影院！这不就是我所探求的下一步吗！昏暗中紧紧依靠着落座，在闪耀着光芒的另一侧进入同样的梦境。从咖啡厅到电影院——这才是正确的发展方向呀！善男信女该行之路。</p><p>我把这件事说出来。</p><p>“这样啊”，樋口如是说到。</p><p>“原来如此，这就是所谓平凡呀。但是平凡才是王道，王道才是王道！世人就是这般催人泪下苦苦用心，在难以分辨的黑暗中紧紧握住意中人的手的吧。”</p><p>之后我们抱着狸猫文学赏奖品的蜜柑箱一路返回。</p><p>那么，因为给你写信浮现出太多开心的事，我不知不觉就写了许多没用的东西。再次献上歉意。总之这封信不过就是“不一起去电影院吗”这种朴素的邀请。平凡才是王道，王道才是王道。以防万一，容我做个补充，我保证不会在黑暗中，不经允许就做握住你的手之类的羞耻事情。如果能有机会共同享受银幕的冒险，荣幸之极。</p><p>静候回音，</p><p>$\qquad$ $\qquad$ $\qquad$ 恐惶谨言。</p><p><img src="https://s2.loli.net/2022/12/28/MtZd3B4heqyo7sn.webp" alt="20-1.webp" title="现实中的进进堂"></p><hr><blockquote><p>原文：<a href="https://www.douban.com/note/643884651">https://www.douban.com/note/643884651</a><br>作者：豆瓣用户 一切顺利！</p></blockquote><h2 id="【剧场特典2】乙女给前辈的回信（自翻）"><a href="#【剧场特典2】乙女给前辈的回信（自翻）" class="headerlink" title="【剧场特典2】乙女给前辈的回信（自翻）"></a>【剧场特典2】乙女给前辈的回信（自翻）</h2><p>拜启。</p><p>你好，感谢之前的郑重来信。</p><p>托你的福，我现在就像才刚擦亮的苹果一样精神。</p><p>拜见了前辈的来信之后，有些无论如何都想传达的记忆咕噜咕噜地涌上心来，所以我就默念着“迸发吧，我的文才！”写下了回信。</p><p>前几天，应羽贯的邀请，我们一起出门要去银阁寺散步。早上开始飘起雪花，从今川通路往上看，能看到大文字也着了美丽的银装。但是一点也不冷。因为我本来就是不怕冷的类型，再加上还穿了羽贯给的软蓬蓬的羽绒服。</p><p>考虑到要去银阁寺，我们在门前町吃了热乎乎的鸡蛋馄饨。吃完之后感觉自己变成了刚出烤箱的面包，热气腾腾的。落在脸颊的雪转瞬就融化了。</p><p>“只是站在旁边就能感受到你传来的热乎空气”，羽贯惊讶地说到，“你为什么那么热乎呢？真想每家放一个取暖呢。”</p><p>非常荣幸，但是到了夏天一定就变得碍事了吧。</p><p>看着周围卖的伴手礼商品穿过门前町的时候，我们和一位不可思议的绅士变成了并行的状态。是位穿着西装套着高级外套、胡子漂亮翘起的老人。并不知道对方的名字，但是感觉和萨尔瓦多•达利非常像，我就在心里决定以“萨尔瓦多老爷爷”来称呼他了。萨尔瓦多老爷爷因为寒冷而瑟瑟发抖，大概他是被我身上多余的热气腾腾吸引过来的吧。可能我这种人真是随身暖炉（小型）一般的存在也说不定。</p><p>“到坡下为止，能允许我同行吗，小姑娘。”（“小姑娘”原文为法语源外来词，后文所有“小姑娘”同此。）</p><p>萨尔瓦多老爷爷行了一礼。</p><p>羽贯回了句“是，先生。”（“是，先生。”原文为法语源外来词。）</p><p>为什么是法语呢？我不明白。难道达利不是西班牙人吗。</p><p>边走下充满观光客的门前町，边和萨尔瓦多老爷爷交谈的内容是：适合刚结识的男女出门的合适的地方。和前辈一样，我也想向可以信赖的过来人寻求智慧的答案。</p><p>“不必困扰。请去电影院吧。”萨尔瓦多老爷爷晃动着手杖如是说。</p><p>“银幕的冒险才是，能为刚结识的男女互相间加深理解的可称为心的旅途的东西。在幕布另一侧展现开的是，从这个世界的偏颇现实中解放出来的梦之世界。电影院的黑暗是人工的甘美的夜晚。独自个体的男女肩靠肩，听着对方的呼吸声，清澈悦耳。时而欢笑时而哭泣，两人感受着相同的梦。这是多么雅致诱人的恋情经营法呀。如何呢，小姑娘？并不是只靠视线相交就可以明白对方的事情。只是费力互相瞪眼的话，前路只会变成争斗。如果不是共同度过短短的夜晚，如果不是共同观看美梦，那可是看不到对方的灵魂呦。”</p><p>从萨尔瓦多老爷爷的大演讲中，我受到了深深的启发。想着必须邀请前辈去感受银幕的冒险，我一下子握紧了热乎乎的小小拳头。</p><p>“受教了。”</p><p>但是羽贯似乎有所不满。“电影什么的不行啦。你想呀，每个人想看的电影都不尽相同。要是勉强两人一起去看电影的话……”</p><p>“有和樋口前辈一起去看过吗？”</p><p>“也不是没去过。我是想看时髦的外国影片啦。但樋口不是只看些低级的东西嘛。看合我口味的电影，樋口就会打瞌睡，看合樋口口味的，我就会打瞌睡。两个人都能看到最后的电影简直一部都没有。”</p><p>“这是说了些什么杀气腾腾的话呀，小姑娘！”</p><p>看着没什么精神的萨尔瓦多老爷爷，不知为何我有点同情。</p><p>不知不觉我们走过门前町，都到了银阁寺的路口。在正好要踏上白川上方小桥的时候，萨尔瓦多老爷爷停住了。从栏杆上注视着河面嘟囔道：“是从哪里流过来的呢？”</p><p>我也驻足去看，有一只颜色鲜艳的蜜柑，在河底非常活跃叽里咕噜地翻来转去。看起来，它简直像是在拼尽全力向我冲过来。</p><p>萨尔瓦多老爷爷突然一下子越过栏杆，羽贯和我都吃惊地屏住了呼吸。真是让人无法联想到是老人的敏捷身手。老爷爷像羽毛似的站在河里，捡起流过去的蜜柑，又轻轻地爬了上来。</p><p>听羽贯说完“吓死了!”，老爷爷边拿手帕擦拭湿漉漉的蜜柑边用得意的语气说：“以前，我可是曾作为杂技员出入过摄影棚呢。”</p><p>老爷爷把那个蜜柑放在了我的手上。</p><p>“就把这个蜜柑给苹果一样的小姑娘吧。”</p><p>“万分感谢。”</p><p>“没问题吧，小姑娘。请去感受银幕的冒险。如果能够共同度过短短的夜晚，共同观看美梦的话——”</p><p>萨尔瓦多老爷爷很熟练地眨眼使了个眼色，抚摸下胡子摇着手杖朝南边的方向走去了。我连向老爷爷道谢，感谢他提供了宝贵意见的机会都没有。如风来，似风去。我想，这简直就像是和电影之神擦肩而过一样。我保持抱着蜜柑的姿势，目送老爷爷的背影离去。</p><p>“真是奇怪的老爷爷呀。”羽贯如是说。</p><p>“是非常出色的人。”</p><p>“你打算拿着那个蜜柑回去吗？没事吧，那可是河里流过来的东西呀。”</p><p>“毕竟也是难得的馈赠之物。”</p><p>那个蜜柑小小圆圆的，滑溜溜地大放光芒。</p><p>从白川上流的方向处传来了“咘—”的奇怪声音。那是修行僧的法螺吧，羽贯这么说到。这么说的话，也真是挺宝贵的声响。</p><p>就这么要踏上归途的时候，羽贯“啊”的一声叫起来，抓住了我羽绒服的下摆。</p><p>“这种地方居然开了个洞？！”</p><p>羽贯给我的软蓬蓬桃色羽绒服上居然开了一个小洞。从中一直有羽毛漏出。这是怎么回事呀。之前还因为身边有那么多软乎乎的白色东西，在想“这雪还真是一时停不下来呀”。</p><p>结果竟然是从羽绒服里漏出的羽毛—真是太羞耻了。真想钻进衣服上的小洞里。话虽如此，这么下去也不行，我就用从萨尔瓦多老爷爷那里得到的蜜柑挡住了破洞，边保护着剩余的羽毛边急匆匆地往回赶。</p><p>到此为止就是想传达给前辈的事情。</p><p>已经明白了我在意的东西，前辈也不需要担心流入白川的蜜柑的去向啦。因为那个蜜柑由我好好地带回家了。还有在北白川天神落在前辈肩头的羽毛，也一定是被我在银阁寺门前掉落又乘风到你身边的吧。</p><p>真是奇遇呢！</p><p>然后，关于接下来要迈出的一步，前辈进行了那么认真的研究，我非常开心。当然我也赞成前辈的提议。</p><p>来吧，向着人工的夜晚中映出的梦之世界。春宵苦短，少女前进吧！</p><p>自心底期待和你的见面。         </p><p>$\qquad$ $\qquad$ $\qquad$ 敬具。</p><p><img src="https://s2.loli.net/2022/12/28/QyLcBd5EPrpICs3.webp" alt="20-2.webp" title="银阁寺"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可以看作是《春宵苦短，少女前进吧》的后续。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://movie.douban.com/review/8521843/&quot;&gt;https://movie.douban.com/review/8521843/&lt;</summary>
      
    
    
    
    <category term="转载" scheme="https://loveofpeach.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="acg" scheme="https://loveofpeach.github.io/tags/acg/"/>
    
  </entry>
  
  <entry>
    <title>影评《春宵苦短，少女前进吧》</title>
    <link href="https://loveofpeach.github.io/posts/dc1dbc8f.html"/>
    <id>https://loveofpeach.github.io/posts/dc1dbc8f.html</id>
    <published>2022-12-27T04:52:14.000Z</published>
    <updated>2023-01-14T06:30:45.866Z</updated>
    
    <content type="html"><![CDATA[<p>姑且放个免费的观看链接：<a href="https://www.yhdmp.live/showp/17348.html">https://www.yhdmp.live/showp/17348.html</a> ，如果你的浏览器没有广告屏蔽插件，可能会看到形形<strong>色色</strong>的广告，但是不影响，没有恶意遮挡的广告，并且全屏观看时没有广告。</p><p>似乎是官方网站：<a href="https://kurokaminootome.com/">https://kurokaminootome.com/</a></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我的记忆力很差，因而电影、小说之类的东西，只在脑海里留下一个模糊的印象。譬如小时候读曹文轩的书，漫长的时间过去，只觉得好似薄荷糖一般。这部改编自森见登美彦小说的电影，看完也只觉得很好，很清爽，但要将这模糊的感觉写下，做出一个影评来，对我来说实在勉强。</p><p>为做好这篇影评，我在网上参考了同类文章（网评/论文，主要是中文），也发现了一些问题。</p><p>以我之愚见，观看一部动画电影时，首要义务是抛弃自己的经验，进入银幕另一侧的世界中去。『在幕布另一侧展现开的是，从这个世界的偏颇现实中解放出来的梦之世界』，这梦之世界中的男女都是自由的，他们的一切行动都可以看作是象征、隐喻、夸张、想象，一切的象征、隐喻、夸张、想象，也都可以是他们的实际行动。因此不必试图在电影中寻求现实的影子，也毋须将现实中的人际关系与行动逻辑与电影对比。</p><blockquote><p>《日本动画“无影作画”技法的美学研究（张长）》：<br>在爱森斯坦看来，动画中的形象就具有这种特性。它们作为一种被画出来的形式，拥有特定的外观，但却如原生质一般活动，总是处在一种尚不具备稳定形式的状态中，<strong>简言之，就是一种可以成为任何事物的潜在能力。这是一种兼具了破坏性与创造性的暴力，它让人们相信，动画形象可以被用来冲破各种限制，从而自由地去进行表达。</strong>……不过，随着迪士尼后来的现实主义转向，动画原生的自由也逐渐被抛弃和抑制了。正像韦尔斯所说，“随着迪士尼的每一次技术进步，他们就越来越远离他们在早期的《糊涂交响曲》中所表现出的原生质的灵活性，强行将动画形式裹挟到新现实主义的实践当中。”从此以后，“动画电影中图形和叙事的无政府状态般的意识形态自由，也让位给了现实情境中的道德评比。” 由此可见，放大和张扬动画“原生质性”的做法就意味着一条与现实主义截然相反的道路，它能够将人们从物质的、现实的、既定的法则和限制中解放出来，以自由的、精神的形态去活动、去表达。</p></blockquote><h2 id="整体印象"><a href="#整体印象" class="headerlink" title="整体印象"></a>整体印象</h2><p>《春宵苦短，少女前进吧》（以下简称《春宵》）是一部非常“日本”的动画，包含了很多鲜明的文化元素。</p><blockquote><p><em><a href="https://www.diva-portal.org/smash/record.jsf?pid=diva2%3A1717186">BEYOND REALIA –CULTURAL ASSOCIATIONS IN THE ENGLISH TRANSLATION OF THE NIGHT IS SHORT, WALK ON GIRL BY MORIMI TOMIHIKO</a> :</em><br>By carefully selecting these cultural elements, the author constructs a literary style that is reminiscent of modern Japanese literature from Taisho (1912-1926) and early Showa (1926-1989). His style also effectively creates a universe that exudes traditional Japanese aesthetic associations expressed by both cultural objects (e.g., food, art, music, decorative objects) and legendary beings (e.g., gods, monsters).</p></blockquote><p><img src="https://bu.dusays.com/2023/01/01/63b1944f75a28.png" alt="拼酒的场景布置"></p><p><img src="https://bu.dusays.com/2023/01/01/63b1944d81ff1.png" alt="五山送火"></p><p><img src="https://bu.dusays.com/2023/01/01/63b19449c00fb.png" alt="樋口吐出的鲤鱼旗"></p><p>这些颇具历史文化气息的元素，在银幕和观众间砌起高墙，同时与现实划清界限：它是现代社会的避难所、田园诗式的保留地。没有高楼大厦，没有通勤的人流——鸭川中站着苹果一般的女孩。</p><p>在这匿藏于银幕的保留地里，一切事物都是『以自由的、精神的形态去活动』，而这正是汤浅政明所擅长的——</p><p><img src="https://bu.dusays.com/2023/01/02/63b1d22f55bcf.png" alt="愿作深海鱼，四周便填满海水"></p><p><img src="https://bu.dusays.com/2023/01/02/63b1d22f23a23.png" alt="被抓住的书像鱼一样挣扎（需要在电影中观看）"></p><p><img src="https://bu.dusays.com/2023/01/02/63b1d22da884d.png" alt="杯中液体表现出果冻般的性质"></p><p><img src="https://s2.loli.net/2023/01/02/2XPhnRlDsJoCAUG.png" alt="向浪漫引擎注入纯爱硝化甘油"></p><p>与之相应的是视觉上的艳丽，它一方面强调了作品的非现实性和自由的基调，另一方面色彩的对比也暗示了人物的心理状态：</p><p><img src="https://bu.dusays.com/2023/01/02/63b24f644ce0c.png" alt="酒吧里的酒水"></p><p><img src="https://bu.dusays.com/2023/01/05/63b695a7d1a67.png" alt="色彩对比"></p><p><img src="https://bu.dusays.com/2023/01/02/63b24f674624e.png" alt="羽贯骗酒"></p><p>《春宵》中《四叠半》的彩蛋：</p><p><img src="https://s2.loli.net/2023/01/02/BHA7xTcblf2tgoI.jpg" alt="《四叠半时光机布鲁斯》，羽贯（右）"></p><p><img src="https://bu.dusays.com/2023/01/02/63b255260828d.png" alt="明石的饼熊玩偶"></p><div class="tip error"><p>以下包含剧透</p></div><p>以下草稿：</p><h2 id="东堂"><a href="#东堂" class="headerlink" title="东堂"></a>东堂</h2><p><img src="https://bu.dusays.com/2023/01/05/63b69667d937a.png" alt="东堂的初次登场"></p><p>东堂是一个妻离女散的中年色鬼大叔，正在收集情色相关的文化遗产，『自称在闺房调查团，其实是个下流的团体（羽贯）』。</p><psw>有些图片实在找不到合适的图床上传，万一给我封了得不偿失。</psw><p>东堂好色无疑，但同时也认为自己时“保护文化遗产”，其实这并不矛盾。</p><p><img src="https://s2.loli.net/2023/01/05/LDmNVQcRXu3gsaP.png" alt="将要失去春宫画时的发言"></p><p>他曾做过鲤鱼养殖，后来被一阵龙卷风吹跑，赔光裤衩。</p><p><img src="https://bu.dusays.com/2023/01/05/63b6a480a5261.png" alt="东堂的经历"></p><h2 id="内裤头目"><a href="#内裤头目" class="headerlink" title="内裤头目"></a>内裤头目</h2><h2 id="黑发少女（女主）"><a href="#黑发少女（女主）" class="headerlink" title="黑发少女（女主）"></a>黑发少女（女主）</h2><h2 id="学长（男主）"><a href="#学长（男主）" class="headerlink" title="学长（男主）"></a>学长（男主）</h2><hr><blockquote><p>《日本动画“无影作画”技法的美学研究（张长）》：<br>他的很多动画都给人一种没有阴影的感觉，不仅仅是没有深色色块所表示的角色暗部，通常也没有角色投影，就连背景也时常没有阴影。或者说，在他的作品中没有“现实”的阴影，即使偶尔在角色身上出现了阴影，那多半也是内心的阴影、想象的阴影、主观的阴影。在汤浅政明看来，阴影就是自然世界和客观现实的符号，它之所以将阴影排除在他的作品之外，就是因为比起外部的现实世界，他更乐意表现内部的心灵世界。<br>……<br>汤浅政明在这部影片里有意地以时间而非空间为舞台，让形形色色的人们登台表演，上演丰富而又离奇的人生戏剧。有的人在这里上演的只是人生的一个瞬间，有的人则在这里演完了一生——在相同的能指时间内，不同的角色经历了不同的所指时间。在年轻的女主人公的心里，每一个短促的瞬间体验都是丰沛而又鲜活的，时间因此被拉扯地悠远绵长；而在年迈的长者那里，他的感受力早已被岁月磨损，数载年华也如白驹过隙。这一点在片中也有较为直接地表述——当女主角和一群老人一同抬起手表看时间的时候，老人们的指针走得飞快，而女主角的指针则走得十分缓慢。心理时间是相对的、主观的、可以伸缩变形的。在这部影片里，汤浅政明通过各种生动的意象和巧妙的叙事手法，将自身的影像风格很好地融入到对多层次的心理时间的探索当中。<br>……<br>外部的现实世界对应着一系列物理法则，这些法则总是限制着事物自我显现的方式。外部世界中的事物遵循着这些法则，因而角色总是被阴影牢牢跟随着。……<strong>我们可以将阴影看成是现实的注脚，在现实之光的朗照之下，事物就不能自行摆脱阴影。而一旦阴影被藏匿起来，影像表征现实的合法性就遭到了动摇，由此观众便会自然地将影像过渡到非现实的领域当中，也即幻觉与想象的精神领域中。</strong> 换言之，阴影通过缺席的方式把叙述的视点从人物的外部引向了内部。在这个过程中我们可以看到，阴影自始至终都被看成是意指现实的符号，它从一开始就肩负着表意的任务，只不过它所肩负的表意任务是通过缺席的方式来履行的。如果说阴影的在场意味着我们所看到的都是现实形象，那么阴影的缺席就意味着眼前的都是心理形象。在汤浅政明这里，他就是通过刻意隐匿各类阴影的方式，使他的观众对其动画影像所表征的对象“另眼相看”的。<br>……<br>我们也可以这样理解，汤浅政明动画中的角色之所以没有阴影，就是因为他们都只是从某个人物受限的视角内所能观察到的极为扁平的他人形象，对角色阴影的排除其实就是为了强调个人主观视角的局限性。 </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;姑且放个免费的观看链接：&lt;a href=&quot;https://www.yhdmp.live/showp/17348.html&quot;&gt;https://www.yhdmp.live/showp/17348.html&lt;/a&gt; ，如果你的浏览器没有广告屏蔽插件，可能会看到形形&lt;strong</summary>
      
    
    
    
    <category term="ACG" scheme="https://loveofpeach.github.io/categories/ACG/"/>
    
    
    <category term="acg" scheme="https://loveofpeach.github.io/tags/acg/"/>
    
    <category term="汤浅政明" scheme="https://loveofpeach.github.io/tags/%E6%B1%A4%E6%B5%85%E6%94%BF%E6%98%8E/"/>
    
    <category term="电影" scheme="https://loveofpeach.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>我再也受不了校园暴力了</title>
    <link href="https://loveofpeach.github.io/posts/659fb3be.html"/>
    <id>https://loveofpeach.github.io/posts/659fb3be.html</id>
    <published>2022-11-29T02:43:21.000Z</published>
    <updated>2022-12-06T14:21:23.465Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i0.sinaimg.cn/edu/2014/1121/U5926P42DT20141121134611.jpg" alt="18-1.jpg"></p><p>事情是这样的。</p><p><img src="https://s2.loli.net/2022/11/29/eoEL3b6w7QT8GPD.jpg" alt="18-2.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://i0.sinaimg.cn/edu/2014/1121/U5926P42DT20141121134611.jpg&quot; alt=&quot;18-1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;事情是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.lol</summary>
      
    
    
    
    <category term="杂" scheme="https://loveofpeach.github.io/categories/%E6%9D%82/"/>
    
    
  </entry>
  
  <entry>
    <title>CppNote</title>
    <link href="https://loveofpeach.github.io/posts/54b4d7a2.html"/>
    <id>https://loveofpeach.github.io/posts/54b4d7a2.html</id>
    <published>2022-11-12T10:23:40.000Z</published>
    <updated>2023-01-22T14:45:39.508Z</updated>
    
    <content type="html"><![CDATA[<p>本文是通过《C++ primer》进行的查漏补缺。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>标准库定义了4个IO对象：</p><ul><li>cin : istream类型的对象，标准输入（standard input）</li><li>cout : ostream类型的对象，标准输出（standard output）</li><li>cerr : ostream类型的对象，标准错误（standard error）</li><li>clog : ostream类型的对象，用来输出程序运行时的一般信息</li></ul><p>一种不用namespace std的写法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;enter two numbers:&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">int</span> v1=<span class="number">0</span>, v2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::cin&gt;&gt;v1&gt;&gt;v2;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the sum of &quot;</span>&lt;&lt;v1&lt;&lt;<span class="string">&quot; and &quot;</span>&lt;&lt;v2&lt;&lt;<span class="string">&quot; is &quot;</span>&lt;&lt;v1+v2&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::cout</code> 两个冒号是一个运算符，作用域运算符。它表示我要把<code>std</code>作用域里面的<code>cout</code>拿出来用。</p><p><code>endl</code> 操作符，结束当前行，将设备相关的缓冲区内容刷到屏幕上。</p><p><code>cin</code>可以跳过空格、制表符、换行符等空白字符。</p><p>一般来说，自己创建的头文件，用双引号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>, value=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;value)&#123; <span class="comment">//读取数值直到文件结尾，或读入错误</span></span><br><span class="line">        sum+=value;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the sum is &quot;</span>&lt;&lt;sum&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，无效的istream对象会使条件变为假，例如输入一个字母（非int型）。</p><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p><code>char</code>比较特殊，分为三种：<code>char</code>、<code>signed char</code>、<code>unsigned char</code>，<code>char</code>是<code>signed char</code>或<code>unsigned char</code>其中的一种，由编译器决定：VC编译器、x86上的GCC都把char定义为<code>signed char</code>，而arm-linux-gcc把char定义为<code>unsigned char</code>。</p><p>为了保持程序的移植性，应当明确指出到底是哪一种。</p><p>三者都占1个字节。<code>signed char</code>取值范围是<code>-128~127</code>(有符号位)，<code>unsigned char</code>取值范围是<code>0~255</code>。</p><p>原始的ASCII标准里，定义的字符码值是只有<code>0~127</code>，所以怎么定义的char都刚好装得下。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>记一种写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">book</span><span class="params">(<span class="string">&quot;newbrush&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//what...?</span></span><br><span class="line">    std::cout&lt;&lt;book&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果（输出了字符串）：</span></span><br><span class="line"><span class="comment">//newbrush</span></span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>; <span class="comment">//以前的写法</span></span><br><span class="line"><span class="type">int</span> units_sold = &#123;<span class="number">0</span>&#125;; <span class="comment">//列表初始化（C++11）</span></span><br><span class="line"><span class="type">int</span> units_sold&#123;<span class="number">0</span>&#125;; <span class="comment">//列表初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>若使用列表初始化，且初始值存在丢失信息的风险，则编译器报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld=<span class="number">3.1415926536</span>;</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;,b=&#123;ld&#125;; <span class="comment">//报错，转换未执行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>,d</span>=ld; <span class="comment">//旧写法，不报错，转换执行，同时丢失了部分值</span></span><br></pre></td></tr></table></figure><p>若只声明而不定义，就在变量前添加<code>extern</code>关键字，且不要显式地初始化变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明 i 而非定义 i</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">//声明并定义 j</span></span><br></pre></td></tr></table></figure><p>若不希望别的文件通过<code>extern</code>引用，可以使用<code>static</code>，这样作用域就是本文件。</p><p><strong>总结：</strong><code>extern</code>不是定义，是引入（声明）在其他源文件中定义的非<code>static</code>全局变量。</p><p>名字的作用域（scope）：</p><ul><li>同一个名字出现在程序的不同位置，也可能指向不同的实体。</li><li>C++中大多数作用域都以花括号分隔。</li><li>名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端作为结束。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个不好的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>; <span class="comment">// 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> unik = <span class="number">0</span>; <span class="comment">//块作用域</span></span><br><span class="line">    std::cout&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unik&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">//同名的新建局部变量，覆盖了全局变量</span></span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unik&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;::reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unik&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//显式地访问全局变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------运行结果-----------</span></span><br><span class="line"><span class="comment">42 0</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">42 0</span></span><br><span class="line"><span class="comment">-------------------------------*/</span></span><br></pre></td></tr></table></figure><h2 id="复合类型（compound-type）"><a href="#复合类型（compound-type）" class="headerlink" title="复合类型（compound type）"></a>复合类型（compound type）</h2><p>引用（reference），为对象起的别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival; <span class="comment">//refVal 指向ival (是ival的另一个名字)</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2; <span class="comment">//报错，引用必须初始化</span></span><br></pre></td></tr></table></figure><p>定义引用时，把引用和它的初始值绑定在一起，而不是把初始值拷贝给引用。引用不是对象，所以不能定义引用的引用，不能定义指向引用的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reVal = <span class="number">2</span>; <span class="comment">//把2给refVal指向的对象，即赋给了ival</span></span><br><span class="line"><span class="type">int</span> li = refVal; <span class="comment">//等同于li=ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal3 = refVal; <span class="comment">//正确：refVal3绑定到了那个与refVal绑定的对象上，即绑定了ival</span></span><br></pre></td></tr></table></figure><p>可以使用取地址符<code>&amp;</code>获取指针所封装的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">//p是指向ival的指针</span></span><br><span class="line"><span class="type">double</span> *dp = &amp;ival; <span class="comment">//错误！类型不匹配</span></span><br></pre></td></tr></table></figure><p>可以使用解引用符<code>*</code>利用指针访问对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">//p是指向ival的指针</span></span><br><span class="line">std::cout&lt;&lt;*p; <span class="comment">//输出42</span></span><br><span class="line">*p=<span class="number">0</span>;</span><br><span class="line">std::cout&lt;&lt;*p <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure><p>空指针（null pointer），不指向任何对象。在使用一个指针前，可以先检查它是否为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">//C++11 ，推荐写法</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">//需要 #include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">p1 = zero; <span class="comment">//错误！类型不匹配</span></span><br></pre></td></tr></table></figure><p>void *指针，纯粹的地址封装，与类型无关。可以用于存放任意对象的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"><span class="type">void</span> *pv = &amp;obj;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure><p>指向指针的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;</span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi; <span class="comment">//ppi指向一个int型的指针</span></span><br></pre></td></tr></table></figure><p>指针的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">//r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i; <span class="comment">//r引用了一个指针，就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//解引用得到i，将i的值改为0</span></span><br></pre></td></tr></table></figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p><code>const</code>对象必须初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="built_in">get_size</span>(); <span class="comment">//正确，运行时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">42</span>; <span class="comment">//正确，编译时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k; <span class="comment">//错误！未初始化</span></span><br></pre></td></tr></table></figure><p>默认状态下，<code>const</code>对象仅在文件内有效，若想在多个文件间共享<code>const</code>对象，必须在变量的定义之前添加关键字<code>extern</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">//file_1.h头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br></pre></td></tr></table></figure><p><code>const</code>的引用，对常量的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci; <span class="comment">//错误！存在通过r2改变ci（const）的风险</span></span><br></pre></td></tr></table></figure><p>一个奇怪的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval; <span class="comment">//允许</span></span><br><span class="line"><span class="type">int</span> &amp;ri = dval; <span class="comment">//错误！因为改变的是编译器生成的中间量</span></span><br></pre></td></tr></table></figure><p>指向常量的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi; <span class="comment">//错误！存在通过ptr指针修改pi的风险</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;</span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">//错误！</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval; <span class="comment">//正确，但不能通过cptr修改dval的值</span></span><br></pre></td></tr></table></figure><p>const指针（必须初始化）：不变的是指针本身的值，而不是它指向的那个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb; <span class="comment">//常指针，顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi; <span class="comment">//指向常量的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*curErr)&#123;</span><br><span class="line">    <span class="built_in">errorHandler</span>();</span><br><span class="line">    *curErr = <span class="number">0</span>; <span class="comment">//正确，试图修改变量errNumb</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pip = <span class="number">2.71</span>; <span class="comment">//错误！试图修改常量pi</span></span><br></pre></td></tr></table></figure><p>顶层<code>const</code>：表示变量本身是一个常量。底层<code>const</code>：表示指针所指向的对象是一个<code>const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">//顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>; <span class="comment">//顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci; <span class="comment">//底层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">//（左：底层），（右：顶层）</span></span><br><span class="line"></span><br><span class="line">p2 = p3; <span class="comment">//正确。从顶层的角度来说，p2是个变量，p3是个常量，</span></span><br><span class="line">         <span class="comment">//这个赋值没有问题。从底层的角度来说，都是一样的，</span></span><br><span class="line">         <span class="comment">//指向的内容都是不会去修改的</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = p3; <span class="comment">//错误！存在通过*p修改*p3（const）的风险</span></span><br><span class="line">             <span class="comment">//p3的底层是const int ，而这个是int</span></span><br><span class="line"></span><br><span class="line">p2 = &amp;i; <span class="comment">//正确。只是不能通过p2修改i而已</span></span><br></pre></td></tr></table></figure><p><code>constexpr</code>变量（C++11标准）：允许将变量声明为<code>constexpr</code>类型，以便由编译器来验证变量的值是否是一个常量表达式。</p><ul><li>一定是一个常量</li><li>必须用常量表达式初始化</li><li>自定义类型、IO库、string等类型不能被定义为<code>constexpr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>(); <span class="comment">//只有当size是一个constexpr函数时才正确</span></span><br></pre></td></tr></table></figure><p>指针和<code>constexpr</code>：限定符仅对指针有效，对其所指的对象无关。（对顶层有效，底层无效）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *np = <span class="literal">nullptr</span>; <span class="comment">//常指针</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//i和j必须定义在函数之外</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *p = &amp;i; <span class="comment">//p是常指针，指向常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p1 = &amp;j; <span class="comment">//p1是常指针，指向变量j</span></span><br></pre></td></tr></table></figure><h2 id="typedef、auto、decltype"><a href="#typedef、auto、decltype" class="headerlink" title="typedef、auto、decltype"></a>typedef、auto、decltype</h2><p>类型别名，提高可读性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base是double的同义词，p是double *的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//C++11，别名声明。左边是别名</span></span><br></pre></td></tr></table></figure><p>对于指针，类型别名的使用可能会产生意想不到的结果（平时不用就好了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps; <span class="comment">//ps是指针变量，它的对象是指向char的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>; <span class="comment">// ! 是对 const pstring cstr = 0; 的错误理解</span></span><br></pre></td></tr></table></figure><p>auto类型说明符，C++11，让编译器通过初始值推断变量的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>; <span class="comment">//错误！auto已经被推断为int，后面却不一致</span></span><br></pre></td></tr></table></figure><p>看看就好，不要较真，我觉得一般不会用到这些：</p><p><img src="https://s2.loli.net/2022/11/14/UkY4gMpC5uBAzGT.png" alt="17-1.png"></p><p><code>decltype</code>类型说明符，获取表达式的类型。在编译时推导出一个表达式的类型，并且不会计算表达式的值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>;             <span class="comment">// y -&gt;  int</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) z = x + y;     <span class="comment">// z - &gt;  int</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;            <span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;    <span class="comment">// p-&gt; const int *</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *pi = &amp;z;         <span class="comment">// pi -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(pi) *pp = π        <span class="comment">//pp -&gt; int**</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;      <span class="comment">//sum的类型就是函数f返回的类型</span></span><br></pre></td></tr></table></figure><p>auto与decltype类似但是又不同，auto只能根据变量的初始化表达式推导出变量应该具有的类型。decltype将精确的推导出表达式定义的类型，不会舍弃和弃用cv限定符。</p><p>一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">//错误！解引用表达式，c的类型为引用，需要初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确，e是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误！d是int&amp;类型，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(((i))) d1 = i; <span class="comment">//正确，d1是int&amp;类型，且已初始化</span></span><br></pre></td></tr></table></figure><h2 id="自定义数据结构、类和头文件"><a href="#自定义数据结构、类和头文件" class="headerlink" title="自定义数据结构、类和头文件"></a>自定义数据结构、类和头文件</h2><p>类定义可以使用关键字<code>class</code>或<code>struct</code>，二者默认的继承、访问权限不同，<code>struct</code>是<code>public</code>的，<code>class</code>是<code>private</code>的。</p><p>编写自己的头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H <span class="comment">//习惯大写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p><img src="https://s2.loli.net/2022/11/25/HXwmQflsYF41znv.png" alt="17-2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">cout&lt;&lt;s1&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输入：hello world</span></span><br><span class="line"><span class="comment">//输出：helloworld</span></span><br><span class="line"><span class="comment">//s1装的是hello，s2是world</span></span><br></pre></td></tr></table></figure><p><code>getline</code>得到的<code>string</code>对象不包含换行符:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="comment">//每次读入一整行，包括空白，直到文件末尾</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,line))&#123;</span><br><span class="line">        cout&lt;&lt;line&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字面值和<code>string</code>对象相加：</p><p><img src="https://s2.loli.net/2022/11/25/yMczalb4n3OQCLm.png" alt="17-3.png"></p><p><code>cctype</code>中的一些函数：</p><p><img src="https://s2.loli.net/2022/11/25/b9YDqtAjkcyR2M5.png" alt="17-4.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(string::size_type i=<span class="number">0</span>; i!=s.<span class="built_in">size</span>(); i=i+<span class="number">2</span>)</span><br><span class="line">    s[i]=<span class="string">&#x27;x&#x27;</span>;  <span class="comment">//一个使用string::size_type的例子</span></span><br></pre></td></tr></table></figure><p>从逻辑上讲，<code>size()</code>成员函数应该似乎返回整型数值，但事实上，size操作返回是<code>string::size_type</code>类型的值。string类类型和其他许多库类型都定义了一些配套类型（companion type）。通过这些配套类型，库函数的使用就与机器无关（machine-independent）。size_type就是这些配套类型中的一种。它定义为与unsigned型（<code>unsigned int</code>或<code>unsigned long</code>）具有相同含义，而且保证足够大的能够存储任意的string对象的长度。<code>string::size_type</code>在不同的机器上长度可以不同，并非固定。但只要使用该类型，就使得程序适合机器。string对象的索引也应为size_type类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序例子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">decltype</span>(s.<span class="built_in">size</span>())punct_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123; <span class="comment">//for every char in s</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ispunct</span>(c))++punct_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    string orig = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123; <span class="comment">//需要修改字符串s</span></span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p><img src="https://s2.loli.net/2022/11/25/jYlGPQ4V6nuig8J.png" alt="17-5.png"></p><p>访问<code>vector</code>的一种方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : v)&#123; <span class="comment">//与上例类似</span></span><br><span class="line">        i*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/25/2JFIf4hT1QczuP3.png" alt="17-6.png"></p><h2 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h2><p>有迭代器的类型都拥有<code>begin</code>和<code>end</code>成员。如果容器为空，则<code>begin</code>和<code>end</code>返回的是同一个迭代器，都是<code>尾后迭代器</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>();</span><br><span class="line"><span class="comment">//b表示v的第一个元素，e表示v尾元素的下一位置</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/01/YQj2wMSRmpxkAZ8.png" alt="17-7.png"></p><p>迭代器类型，<code>iterator</code>和<code>const_iterator</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">//it能读写vector&lt;int&gt;元素</span></span><br><span class="line">string::iterator it2; <span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3; <span class="comment">//it3只能读，不能写</span></span><br><span class="line">string::const_iterator it4; <span class="comment">//it4只能读，不能写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----分--割--线--QAQ-----*/</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>(); <span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>(); <span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----分--割--线--QAQ-----*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时我们希望即使对象不是常量，也使用const_iterator，</span></span><br><span class="line"><span class="comment">//C++11引入了cbegin和cend</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>(); <span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>结合解引用的成员访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">(*it).<span class="built_in">empty</span>();</span><br><span class="line">*it.<span class="built_in">empty</span>(); <span class="comment">//错误！</span></span><br><span class="line">it-&gt;<span class="built_in">empty</span>(); <span class="comment">//箭头运算符：把解引用和成员访问两个操作合在一起</span></span><br></pre></td></tr></table></figure><p><strong>任何一种可能改变vector对象容量的操作，都会使得相应的迭代器失效。</strong></p><p>迭代器运算：</p><p><img src="https://s2.loli.net/2022/12/01/Dh14EGjnps7Kf6H.png" alt="17-8.png"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一种写法：<code>int a[]=&#123;1,2,3&#125;;</code>，<code>[]</code>内可以不填数字。</p><p>字符数组的特殊性：字符串字面值的结尾处有一个空字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;; <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="type">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//列表初始化，显式写出了空字符</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span>; <span class="comment">//将自动包含空字符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Danial&quot;</span>; <span class="comment">//错误！没有空间放空字符</span></span><br></pre></td></tr></table></figure><p>复杂的数组声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ？ */</span>; <span class="comment">//错误！不存在引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr; <span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs; <span class="comment">//arry是数组的引用，该数组含有10个指针</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/12/MzaSUBXNf5W8rdi.png" alt="17-9.png"></p><p>数组的<code>begin</code>和<code>end</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p1 = std::<span class="built_in">begin</span>(a);</span><br><span class="line">    <span class="type">int</span> *p2 = std::<span class="built_in">end</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;p1 != p2; p1++)&#123;</span><br><span class="line">        std::cout&lt;&lt;*p1&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----运行结果-----</span></span><br><span class="line"><span class="comment">1 2 3 4</span></span><br><span class="line"><span class="comment">-----------------*/</span></span><br></pre></td></tr></table></figure><p>指针运算：</p><p><img src="https://s2.loli.net/2022/12/12/t3onZmyICzw1viH.png" alt="17-10.png"></p><p>下标和指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;ia[<span class="number">2</span>]; <span class="comment">// 指向“4”</span></span><br><span class="line"><span class="type">int</span> j = p[<span class="number">1</span>]; <span class="comment">// j = 6</span></span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>]; <span class="comment">// k = 0  , string和vector的下标不可以为负</span></span><br></pre></td></tr></table></figure><p>C风格字符串：处理函数定义在<code>cstring</code>头文件中。</p><p><img src="https://bu.dusays.com/2023/01/03/63b3fb10a29b4.png" alt="17-11.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">strlen</span>(ca)&lt;&lt;endl; <span class="comment">//错误！ca[]没有以 &#x27;\0&#x27; 结束</span></span><br></pre></td></tr></table></figure><p>与旧代码的接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> *str = s; <span class="comment">//错误！不能这样用</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>(); <span class="comment">//正确，c风格的string</span></span><br></pre></td></tr></table></figure><p>使用数组初始化<code>vector</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(std::begin(int_arr),std::end(int_arr))</span></span>;</span><br><span class="line"><span class="comment">// 左闭右开</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subVec</span><span class="params">(int_arr+<span class="number">1</span>,int_arr+<span class="number">4</span>)</span></span>; <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>将所有元素初始化为0：<code>int arr[10][20][30]=&#123;0&#125;;</code></p><p>初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia2[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;              <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> ia3[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> ia4[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;; <span class="comment">// &#123;0,0,0,0,4,0,0,0,8,0,0,0&#125;</span></span><br><span class="line"><span class="type">int</span> ia5[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;     <span class="comment">// &#123;0,3,6,9,0,0,0,0,0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure><p>下标引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; <span class="comment">//把row绑定到ia的第二个4元素数组上</span></span><br></pre></td></tr></table></figure><p>使用范围for语句处理多维数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia)        <span class="comment">//对于外层数组的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123; <span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*----------------------</span></span><br><span class="line"><span class="comment">在上面的例子中，因为要改变数组元素的值，所以使用引用类型。</span></span><br><span class="line"><span class="comment">对于没有写操作的，可以参考下例：避免数组被自动转成指针</span></span><br><span class="line"><span class="comment">----------------------*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br><span class="line">        cout &lt;&lt; col &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>指针和多维数组：</p><p><img src="https://bu.dusays.com/2023/01/04/63b4f8690ecd0.png" alt="17-12"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p=ia; p!=ia+<span class="number">3</span>; p++)&#123;</span><br><span class="line">    <span class="comment">//q指向4个整数数组的首元素，也就是说，q指向一个整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q=*p; q!=*p+<span class="number">4</span>; q++)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名简化多维数组的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和上例一样</span></span><br><span class="line"><span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (int_array *p = ia; p!=ia+<span class="number">3</span>; p++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *q = *p; q!=*p+<span class="number">4</span>; q++)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式基础"><a href="#表达式基础" class="headerlink" title="表达式基础"></a>表达式基础</h2><p>概念：左值和右值，上网查。</p><p>如果表达式的求值结果是左值，<code>decltype</code>作用于该表达式（不是变量）得到一个引用类型。例如，对于<code>int *p</code>：</p><ul><li>因为解引用运算符生成左值，所以<code>decltype(*p)</code>的结果是<code>int&amp;</code></li><li>因为取地址运算符生成右值，所以<code>decltype(&amp;p)</code>的结果是<code>int **</code></li></ul><p><strong>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。</strong></p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>m%(-n)</code>等于<code>m%n</code>，<code>(-m)%n</code>等于<code>-(m%n)</code>。</p><h2 id="成员访问、条件、位运算符"><a href="#成员访问、条件、位运算符" class="headerlink" title="成员访问、条件、位运算符"></a>成员访问、条件、位运算符</h2><p>成员访问运算符，<code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a string&quot;</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line">n = (*p).<span class="built_in">size</span>();</span><br><span class="line">n = p-&gt;<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>位运算符作用于整数类型。关于符号位如何处理没有明确的规定，所以强烈<strong>建议仅将位运算符用于处理无符号类型</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设char占8位，int占32位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits = <span class="number">0233</span>; <span class="comment">//八进制，二进制为 10011011</span></span><br><span class="line">bits &lt;&lt; <span class="number">8</span>; <span class="comment">//bits提升为int型，然后左移8位</span></span><br></pre></td></tr></table></figure><p>使用位运算符：假设班级中有30个学生，用一个二进制位表示某个学生在测试中是否通过。例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> quizl = <span class="number">0</span>;</span><br><span class="line">quizl |= <span class="number">1UL</span> &lt;&lt; <span class="number">27</span>; <span class="comment">//学生27通过了测试</span></span><br><span class="line">quizl &amp;= ~(<span class="number">1UL</span> &lt;&lt; <span class="number">27</span>); <span class="comment">//学生27没有通过测试</span></span><br><span class="line"><span class="type">bool</span> status = quizl &amp; (<span class="number">1UL</span> &lt;&lt; <span class="number">27</span>); <span class="comment">//查询学生27是否通过了测试</span></span><br></pre></td></tr></table></figure><h2 id="sizeof和逗号运算符"><a href="#sizeof和逗号运算符" class="headerlink" title="sizeof和逗号运算符"></a>sizeof和逗号运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="built_in">sizeof</span>(Sales_data); <span class="comment">// Sales_data类型的对象所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data; <span class="comment">//和上一行结果一样</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;   <span class="comment">//和上一行结果一样</span></span><br><span class="line"><span class="keyword">sizeof</span> p; <span class="comment">//指针所占空间的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue; <span class="comment">//对象里的成员的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> Sales_data::revenue; <span class="comment">//C++11，和上一行结果一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof运算能够得到整个数组的大小</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia) / <span class="built_in">sizeof</span>(*ia);</span><br><span class="line"><span class="type">int</span> arr2[sz]; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>看看就好，一般不用：</p><p><img src="https://bu.dusays.com/2023/01/06/63b7acd5aa3a6.png" alt="17-13.png"></p><p>指针的转换：</p><ul><li><code>0</code>或字面值<code>nullptr</code>能够转换成任意指针类型</li><li>指向任意非常量的指针能够转换成<code>void*</code></li><li>指向任意对象的指针能够转换成<code>const void*</code></li></ul><p>显式转换：强制转换<code>cast-name&lt;type&gt;(expression)</code>，<code>cast-name</code>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) / i;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">void</span> *p = &amp;d;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p><code>const_cast</code>只能改变运算对象的底层<code>const</code>，对于将常量对象转换成非常量对象的行为，称为『去掉const性质（cast away the const）』。</p><p><code>const_cast</code>可以移除底层<code>const</code>，或是给普通的类型添加底层<code>const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *cp = &amp;a;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line">    *p = <span class="number">4</span>;  <span class="comment">//允许</span></span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------- 对 比 ---------*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *cp = &amp;a;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line">    *p = <span class="number">4</span>; <span class="comment">//没有定义</span></span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>static_cast</code>不能去掉const性质。<code>const_cast</code>不能改变类型。</p><p><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释。</p><p><img src="https://bu.dusays.com/2023/01/07/63b859b8c8e1e.png" alt="17-14.png"></p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><code>switch-case</code>,case标签必须是整型（小整型、bool型、short、char也都可以）常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于switch-case里面的初始化的一个例子</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="type">int</span> c; <span class="comment">//不能初始化！</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;before c = &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">            c = <span class="number">1</span>; <span class="comment">//在case1中声明并定义的c可以在这里使用</span></span><br><span class="line">            <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">//用大括号括起来，则可以初始化</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;after c = &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p>范围<code>for</code>语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//范围变量必须是引用类型，这样才能对元素执行写操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : v)&#123;</span><br><span class="line">    r *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------- 对 比 ---------*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg=v.<span class="built_in">begin</span>(),end=v.<span class="built_in">end</span>(); beg!=end; ++beg)&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = *beg; <span class="comment">//r是引用类型才能对元素执行写操作</span></span><br><span class="line">    r *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p><code>goto</code>语句：无条件跳转到同一函数内的另一条语句。一般情况下不要使用<code>goto</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">    <span class="type">int</span> ix = <span class="number">10</span>; <span class="comment">//错误！goto语句绕过了一个带初始化的变量定义</span></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">//错误！此处的代码需要使用ix</span></span><br><span class="line">    ix = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向后跳过一个初始化的变量定义是合法的</span></span><br><span class="line">begin:</span><br><span class="line">    <span class="type">int</span> sz = <span class="built_in">get_size</span>();</span><br><span class="line">    <span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">goto</span> begin; <span class="comment">//goto语句执行后，将销毁sz</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>运行时的反常行为，例如读取或写入数据时失去数据库链接。</p><p><code>throw</code>表达式：异常检测部分使用<code>throw</code>表达式来表示它遇到了无法解决的问题。</p><p><code>runtime_error</code>是标准库异常类型的一种，定义在<code>stdexcept</code>头文件。它抛出一个异常，终止当前的函数，并把控制权交给处理异常的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于简单的小程序</span></span><br><span class="line">Sales_item item1,item2;</span><br><span class="line">cin &gt;&gt; item1 &gt;&gt; item2;</span><br><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>() == item2.<span class="built_in">isbn</span>())&#123;</span><br><span class="line">    cout &lt;&lt; item1+item2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//表示成功</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Data must refer to same ISBN&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//表示失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------- 对 比 -----------------*/</span></span><br><span class="line"><span class="keyword">if</span> (item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果程序执行到这里，表示两个ISBN是相同的</span></span><br><span class="line">cout &lt;&lt; item1+item2 &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><code>try</code>语句块：异常处理部分使用<code>try</code>语句块处理异常，可以有一个或多个<code>catch</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;item1&gt;&gt;item2)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//执行添加两个Sales_item对象的代码</span></span><br><span class="line">        <span class="comment">//如果添加失败，代码抛出一个runtime_error异常</span></span><br><span class="line">    &#125;<span class="built_in">catch</span>(runtime_error err)&#123;</span><br><span class="line">        <span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">        cout &lt;&lt; err.<span class="built_in">what</span>() <span class="comment">//返回初始化对象时填入的参数（const char*）</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nTry Again? Enter y or n&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (!cin || c==<span class="string">&#x27;n&#x27;</span>) <span class="keyword">break</span>; <span class="comment">//跳出while</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一套异常类：<code>throw</code>表达式和相关的<code>catch</code>子句之间传递异常的具体信息。这些异常分别定义在4个头文件中：</p><ul><li><code>exception</code>头文件：最通用的异常类<code>exception</code>，只报告异常的发生，不提供额外信息</li><li><code>stdexcept</code>头文件：定义了几种常用的异常类</li><li><code>new</code>头文件：<code>bad_alloc</code>异常类</li><li><code>type_info</code>头文件：<code>bad_cast</code>异常类</li></ul><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>局部对象：</p><ul><li>自动对象：生命周期从变量声明开始，到函数块末尾结束</li><li>局部静态对象：生命周期从变量声明开始，直到程序结束才销毁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count_calls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">//自动对象</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> ctr = <span class="number">0</span>; <span class="comment">//局部静态对象</span></span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>指针型变量在函数体中需要被改变的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *&amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于“指针的值+1”的解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello this is a test&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">233</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;adress: &quot;</span>&lt;&lt;p&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;neirong: &quot;</span>&lt;&lt;*p&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;adress+1: &quot;</span>&lt;&lt;p+<span class="number">1</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---------------运行结果----------------</span></span><br><span class="line"><span class="comment">hello this is a test</span></span><br><span class="line"><span class="comment">adress: 0x61fe14</span></span><br><span class="line"><span class="comment">neirong: 233</span></span><br><span class="line"><span class="comment">adress+1: 0x61fe18</span></span><br><span class="line"><span class="comment">---------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------explanation-----------</span></span><br><span class="line"><span class="comment">p+1的效果反映在地址上（单词拼错小问题）</span></span><br><span class="line"><span class="comment">在博主本人的机器上，int型占4个字节</span></span><br><span class="line"><span class="comment">--------------------------------*/</span></span><br></pre></td></tr></table></figure><p>一维数组作为参数，除了将数组名传入函数外，为了规范化，还要将数组的大小作为参数传入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span> <span class="params">(<span class="type">int</span> att[] , <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组名是首元素的地址，因此还可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span> <span class="params">(<span class="type">int</span> *att , <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">   <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是哪种定义，使用函数时都是将数组名作为参数，比如：<code>sum_arr (Ss , 66);</code>。在函数内部对传入的数组进行修改，该数组本身的值也会改变。</p><p>若要防止在函数中修改数组，可以使用<code>const</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> att[] , <span class="type">int</span> size)</span></span></span><br></pre></td></tr></table></figure><p>前面将数组的首元素的地址和长度传入，这样就可以处理所有元素。C++中引入了新的方式，即数组区间：传入数组的首元素地址和末尾地址，参数就是【数组名，数组名+长度】，这样也可以处理所有元素。进一步，也可以传入任意区间。例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *begin,<span class="type">const</span> <span class="type">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pt;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(pt = begin ; pt != end ; pt++)</span><br><span class="line">    &#123;</span><br><span class="line">        total = total + *pt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[Size] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; ;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">sum_arr</span>(A,A+<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>二维数组作为参数，与一维类似，有两种声明方式，但有所区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> A[ ][<span class="number">4</span>] , <span class="type">int</span> size)</span> <span class="comment">//不能写成 int sum(int A[ ][ ] , int size)，必须将列数写进去，size的值是行数</span></span></span><br><span class="line"><span class="function"><span class="comment">//下面一种写法看看就好：</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> (*A)[<span class="number">4</span>] , <span class="type">int</span> size)</span> <span class="comment">//同样，必须将列数写进去，size的值是行数，而且必须要将*和数组名括起来。</span></span></span><br></pre></td></tr></table></figure><p>至于使用方法都是一样，<code>sum(A，4);</code>。第二维长度有较严格的要求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x[][<span class="number">5</span>] , <span class="type">int</span> mysize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">f</span>(a,<span class="number">10</span>); <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">f</span>(b,<span class="number">10</span>); <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure><p>如果函数无需改变引用形参的值，最好将其声明为常量引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++允许将变量定义为数组的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确：形参是数组的引用，维度是类型的一部分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123; <span class="comment">// ()不能少</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)&#123;</span><br><span class="line">        cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>处理命令行选项。有时需要给<code>main</code>传实参，一种常见的情况是用户设置一组选项来确定函数所要执行的操作。例如，假定<code>main</code>函数位于可执行文件<code>prog</code>内，可以向程序传递下面的选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure><p>这些命令行选项通过两个（可选的）形参传递给<code>main</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;<span class="comment">/* do something */</span>&#125;</span><br><span class="line"><span class="comment">/* 第二个形参argv是一个数组，它的元素是指向C风格字符串的指</span></span><br><span class="line"><span class="comment">针；第一个形参argc表示数组中字符串的数量。因为第二个形参是</span></span><br><span class="line"><span class="comment">数组，所以main函数也可以定义成如下的方式： */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;<span class="comment">/* do something */</span>&#125;</span><br><span class="line"><span class="comment">//其中argv指向char*</span></span><br></pre></td></tr></table></figure><p>以上面提供的命令行为例，<code>argc</code>应该等于5，<code>argv</code>应该包含如下的C风格字符串：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;prog&quot;</span>; <span class="comment">//或者argv[0]也可以指向一个空字符串</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-d&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;-o&quot;</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">&quot;ofile&quot;</span>;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">&quot;data0&quot;</span>;</span><br><span class="line">argv[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//最后一个指针之后的元素值保证为 0</span></span><br></pre></td></tr></table></figure><p>含有可变形参的函数：参数个数不固定。如果所有的实参类型相同，可以传递一个名为<code>initializer_list</code>的标准库类型。</p><p><img src="https://bu.dusays.com/2023/01/09/63bbb301623b0.png" alt="17-15.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和vector不一样，initializer_list对象中的元素永远是常量值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg=il.<span class="built_in">begin</span>(); beg!=il.<span class="built_in">end</span>(); ++beg)&#123;</span><br><span class="line">        cout&lt;&lt;*beg&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//excepted和actual是string对象</span></span><br><span class="line"><span class="keyword">if</span>(excepted!=actual)</span><br><span class="line">    <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>,excepted,actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okey&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>省略符形参：上网查。</p><h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p><strong>不要</strong>返回局部对象的引用或指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//严重错误：这个函数试图返回局部对象的引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ret;</span><br><span class="line">    <span class="comment">//以某种方式改变一下ret</span></span><br><span class="line">    <span class="keyword">if</span>(!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret;     <span class="comment">//错误！返回局部对象的引用</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>; <span class="comment">//错误！&quot;Empty&quot;是一个局部临时变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表初始化返回值（C++11）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//expected和actual是string对象</span></span><br><span class="line">    <span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">//返回一个空vector对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125;; <span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>的返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一种写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE; <span class="comment">//定义在cstdlib头文件中</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS; <span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/11/63becdd957edf.png" alt="17-16.png"></p><p><img src="https://bu.dusays.com/2023/01/09/63bc1b6ef129c.png" alt="17-17.png"></p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载：函数名称相同但形参列表不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>; <span class="comment">//错误！有第一行的情况下不能这么写</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Name&amp;)</span></span>;</span><br><span class="line">Account acct;</span><br><span class="line">Phone phone;</span><br><span class="line">Record r1 = <span class="built_in">lookup</span>(acct);</span><br><span class="line">Record r2 = <span class="built_in">lookup</span>(phone);</span><br></pre></td></tr></table></figure><p><code>const_cast</code>和重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string对象的长度，返回较短的那个引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;=s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line">                            <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><p>默认实参：一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht=<span class="number">24</span>, sz wid=<span class="number">80</span>, <span class="type">char</span> backgrnd=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">string mwindow;</span><br><span class="line">mwindow = <span class="built_in">screen</span>(); <span class="comment">//等价于screen(24,80,&#x27; &#x27;)</span></span><br><span class="line">mwindow = <span class="built_in">screen</span>(<span class="number">66</span>); <span class="comment">//等价于screen(66,80,&#x27; &#x27;)</span></span><br><span class="line">mwindow = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>); <span class="comment">//screen(66,256,&#x27; &#x27;)</span></span><br><span class="line">mwindow = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>,<span class="string">&#x27;#&#x27;</span>); <span class="comment">//screen(66,256,&#x27;#&#x27;)</span></span><br><span class="line"></span><br><span class="line">mwindow = <span class="built_in">screen</span>(,,<span class="string">&#x27;?&#x27;</span>); <span class="comment">//错误！只能省略尾部的实参</span></span><br><span class="line">mwindow = <span class="built_in">screen</span>(<span class="string">&#x27;?&#x27;</span>); <span class="comment">//会发生隐式转换</span></span><br></pre></td></tr></table></figure><p><code>constexpr</code>函数：能用于常量表达式的函数，函数的返回类型及所有的形参都是字面值类型。</p><ul><li>函数体中必须有且仅有一条<code>return</code>语句</li><li><code>constexpr</code>函数被隐式地指定为内联函数</li><li><code>constexpr</code>函数并不要求返回常量表达式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>(); <span class="comment">//正确，foo是一个常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">new_sz</span>()*cnt;&#125;</span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)]; <span class="comment">//正确，scale(2)是常量表达式</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)]; <span class="comment">//错误！scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure><p>调试帮助：只在开发过程中使用的代码，发布时屏蔽掉。</p><p><code>assert</code>预处理宏，位于<code>cassert</code>头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果表达式为假，assert输出信息并终止程序的执行</span></span><br><span class="line"><span class="comment">//如果表达式为真，assert什么也不做</span></span><br><span class="line"><span class="built_in">assert</span>(word.<span class="built_in">size</span>()&gt;threshold);</span><br></pre></td></tr></table></figure><p><code>NDEBUG</code>预处理变量：<code>assert</code>的行为依赖<code>NDEBUG</code>预处理变量的状态，如果定义了<code>NDEBUG</code>，则<code>assert</code>无效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG <span class="comment">//关闭调试状态，必须在cassert头文件上面</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br></pre></td></tr></table></figure><p>除了用于<code>assert</code>外，也可以使用<code>NDEBUG</code>编写自己的调试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">//__func__是编译器定义的一个局部静态变量，用于存放函数的名字</span></span><br><span class="line">    cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: array size is &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/11/63bec9792c01a.png" alt="17-18.png"></p><h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>这一节看看就好，感觉用处不太。</p><p><img src="https://bu.dusays.com/2023/01/11/63becd3f25693.png" alt="17-19.png"></p><p>例子如下：</p><p><img src="https://bu.dusays.com/2023/01/11/63becd3f51959.png" alt="17-20.png"></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针，指针指向的是函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;); <span class="comment">//括号不能少</span></span><br><span class="line"></span><br><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">//与上一行等价，取地址符是可选的</span></span><br><span class="line"><span class="comment">//可以直接使用指向函数的指针调用该函数，无需提前解引用</span></span><br><span class="line"><span class="comment">/*------------ 以下三行语句是等价的 ------------*/</span></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="comment">/*--------------------------------------------*/</span></span><br></pre></td></tr></table></figure><p>在指向不同函数类型的指针间不存在转换规则（<strong>必须很精准的匹配才可以</strong>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和上个例子连起来看</span></span><br><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cstringCompare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">pf = <span class="number">0</span>; <span class="comment">//正确，pf不指向任何函数</span></span><br><span class="line">pf = sumLength; <span class="comment">//错误！返回类型不匹配</span></span><br><span class="line">pf = cstringCompare; <span class="comment">//错误！形参类型不匹配</span></span><br><span class="line">pf = lengthCompare; <span class="comment">//正确，精确匹配</span></span><br></pre></td></tr></table></figure><p>函数指针形参：</p><p>不能定义函数类型的形参，但形参可以是指向函数的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个形参是函数类型，它会自动地转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价的声明：显式地将形参定义成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接把函数作为实参使用，会自动转换成指针</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1,s2,lengthCompare);</span><br></pre></td></tr></table></figure><p>通过使用类型别名，简化使用函数指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>; <span class="comment">//等价的类型</span></span><br><span class="line"><span class="comment">//FuncP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>; <span class="comment">//等价的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//useBigger的等价声明，其中使用了类型别名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, Func)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, FuncP2)</span></span>;</span><br></pre></td></tr></table></figure><p>返回指向函数的指针：虽然不能返回一个函数，但是可以返回指向函数类型的指针。<strong>必须把返回类型写成指针形式，编译器不会自动处理。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>); <span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span>*, <span class="type">int</span>); <span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">//错误！F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">//正确，显式地指定返回类型是指向函数的指针</span></span><br></pre></td></tr></table></figure><p>也可以用下面的形式直接声明f1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>)) (<span class="type">int</span>*, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>从里往外读：<code>f1(int)</code>是一个函数，这个函数返回的是一个指针<code>(*f1(int))</code>，这个指针指向的是一个函数 <code>(int*, int)</code>，这个函数<code>(int*, int)</code>返回的是int型。</p><p>使用尾置返回类型的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/01/12/63bfa6a382fb2.png" alt="17-21.png"></p><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><p>考虑如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Sales_data的非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>成员都必须在类的内部<strong>声明</strong>，但成员函数体可以<strong>定义</strong>在类内也可以在类外。</p><p>常量成员函数：类的成员函数后面加<code>const</code>，表明这个函数不会修改这个类对象的数据成员。</p><p>两种效果相同的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Sales_data内：</span></span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;&#125; <span class="comment">//尽管没有必要</span></span><br></pre></td></tr></table></figure><p>关于<code>this</code>的详细解释参考《C++ primer》。</p><p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。因此成员体可以随意使用类中的其他成员而无需在意这些成员出现的次序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类的外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个返回<code>this</code>对象的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟复合运算符+=，为了和+=一致，返回为左值，因此需要返回引用</span></span><br><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123; <span class="comment">//right hand side</span></span><br><span class="line">    units_sold += rhs.units_sold; <span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义类相关的非成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果非成员函数是类接口的组成部分，则应该与类在同一个头文件中声明</span></span><br><span class="line"><span class="comment">//IO对象不能拷贝，只能引用。 需要修改IO对象，不能用底层const</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.uints_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数：</p><ul><li>构造函数与类名同名，没有返回值，用来初始化类对象的数据成员。</li><li>类可以包括多个构造函数。</li><li>构造函数不能被声明为<code>const</code>的<ul><li>当我们创建类的一个<code>const</code>对象时，直到构造函数完成初始化，对象才能真正得到“常量”属性</li></ul></li></ul><p><strong>合成的默认构造函数（synthesized default constructor）</strong>：如果我们的类没有显式地定义构造函数，编译器会为我们隐式地定义一个默认构造函数。对于大多数类来说，这个『合成的默认构造函数』将按照如下规则初始化类的数据成员：</p><ul><li>若存在类内的初始值，用它来初始化成员。</li><li>否则，默认初始化该成员。</li></ul><p><strong>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码慢慢读不难懂，详细解释可以参阅《C++ primer》</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="comment">//新增的构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">               <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">    <span class="comment">//之前已有的其他成员</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...之前的代码略</span></span><br><span class="line"><span class="comment">//在类的外部定义构造函数：</span></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(std::istream &amp;is)&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝、赋值和析构：</p><p>管理动态内存的类通常不能依赖于编译器合成的版本。使用<code>vector</code>或<code>string</code>除外。</p><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用访问说明符加强类的封装性：</p><ul><li><code>public</code>：类的接口，在整个程序内可以被访问</li><li><code>private</code>：封装（即隐藏）类的实现细节</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class和struct定义类唯一的区别就是默认的访问权限不同</span></span><br><span class="line"><span class="comment">//struct默认public， class默认private</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">               <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或函数成为它的<strong>友元</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="comment">// 为Sales_data的非成员函数所做的友元声明</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::istream&amp; <span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 其他内容与之前一致</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">               <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Sales_data接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream&amp; <span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>友元声明只能出现在类定义的内部，但具体位置不限。友元不是类的成员，不受访问控制级别的约束。友元的声明仅指定访问的权限，不是通常意义上的函数声明。因此若希望类的用户能调用某个友元函数，最好在友元声明之外再对函数进行一次声明（有些编译器必须声明，有些可以省略。出于移植性的考虑，最好声明一下）。</p><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>定义一个类型成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Screen表示显示器中的一个窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="comment">//等价于 using pos = std::string::size_type;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    std::string contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这样做的原因是，Screen的用户不需要知道Screen使用了一个string对象来存放它的数据，pos隐藏了细节。</p><p>成员函数也支持重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="built_in">Screen</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Screen</span>(pos ht, pos wd, <span class="type">char</span> c): <span class="built_in">height</span>(ht),<span class="built_in">width</span>(wd),<span class="built_in">contents</span>(ht*wd,c)&#123;&#125;</span><br><span class="line">    <span class="comment">// string初始化的一种方法：使用单个字符初始化。</span></span><br><span class="line">    <span class="comment">// string s(10,&#x27;a&#x27;); //直接初始化，s的内容是aaaaaaaaaa</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> contents[cursor];&#125; <span class="comment">// 隐式内联</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>; <span class="comment">// 显式内联</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r, pos c)</span></span>;       <span class="comment">// 能在之后被设为内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    std::string contents;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span>&#123;</span><br><span class="line">    pos row = r*width;</span><br><span class="line">    cursor = row+c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//以左值的形式返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Screen::get</span><span class="params">(pos r, pos c)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    pos row = r*width;</span><br><span class="line">    <span class="keyword">return</span> contents[row+c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可变数据成员（mutable data member）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr; <span class="comment">//即使在一个const对象内也能被修改</span></span><br><span class="line">    <span class="comment">//其他成员与之前的版本一致，略</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    ++access_ctr; <span class="comment">//保存一个计数值，用于记录成员函数被调用的次数</span></span><br><span class="line">    <span class="comment">//该成员需要完成的其他工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类数据成员的初始值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这个窗口管理类，管理一组Screen</span></span><br><span class="line">    std::vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>, <span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回<code>*this</code>的成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(pos, pos, <span class="type">char</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 其他成员和之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    contents[cursor] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(pos r, pos col, <span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    contents[r*width+col] = ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把光标移动到一个指定的位置，然后设置该位置的字符值</span></span><br><span class="line">    myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);      <span class="comment">// 神之一手</span></span><br></pre></td></tr></table></figure><p>从<code>const</code>成员函数返回<code>*this</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//根据对象是否是const重载了display函数</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span>&#123;</span><br><span class="line">        <span class="built_in">do_display</span>(os);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> Screen&amp; <span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">do_display</span>(os);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        os &lt;&lt; contents;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他成员与之前的一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类的声明：我们可以仅声明类而暂时不定义它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;   <span class="comment">// Screen类的声明</span></span><br></pre></td></tr></table></figure><p>这种声明也叫<strong>前向声明（forward declaration）</strong>，对于类型Screen来说，它在声明之后定义之前是一个<strong>不完全类型（incomplete type）</strong>，不完全类型只能在有限的情况下使用：</p><ul><li>可以定义指向这种类型的指针或引用</li><li>可以声明（但不能定义）以不完全类型作为参数或返回类型的函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link_screen</span>&#123;</span><br><span class="line">    Link_screen *next; <span class="comment">//正确</span></span><br><span class="line">    Link_screen *prev; <span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类之间的友元关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">    <span class="comment">// Window_mgr的成员可以访问Screen类的私有部分</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    <span class="comment">// Screen类的剩余部分，略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 如果一个类指定了友元类，则友元类的成员函</span></span><br><span class="line"><span class="comment">数可以访问此类包括非公有成员在内的所有成员。*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 窗口中每个屏幕的编号</span></span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="comment">// 按编号将指定的Screen重置为空白</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>, <span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// s是一个Screen的引用，指向我们想清空的那个屏幕</span></span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.height*s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元关系不存在传递性。</strong></p><p>令成员函数作为友元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">    <span class="comment">// Window_mgr::clear必须在Screen类之前被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">// Screen类的剩余部分，略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*-------------- 顺 序 ---------------*/</span></span><br><span class="line"><span class="comment">//1、定义Window_mgr类，声明clear函数，但不能定义它</span></span><br><span class="line"><span class="comment">//2、定义Screen，包括对于clear的友元声明</span></span><br><span class="line"><span class="comment">//3、定义clear，此时才能使用Screen的成员</span></span><br></pre></td></tr></table></figure><p>友元声明和作用域：参考《C++ Primer》</p><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p><a href="https://www.bilibili.com/video/BV1z64y1U7hs/?p=39">https://www.bilibili.com/video/BV1z64y1U7hs/?p=39</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是通过《C++ primer》进行的查漏补缺。&lt;/p&gt;
&lt;h2 id=&quot;输入输出&quot;&gt;&lt;a href=&quot;#输入输出&quot; class=&quot;headerlink&quot; title=&quot;输入输出&quot;&gt;&lt;/a&gt;输入输出&lt;/h2&gt;&lt;p&gt;标准库定义了4个IO对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ci</summary>
      
    
    
    
    <category term="笔记" scheme="https://loveofpeach.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://loveofpeach.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>几何角度下的一个公式</title>
    <link href="https://loveofpeach.github.io/posts/12839668.html"/>
    <id>https://loveofpeach.github.io/posts/12839668.html</id>
    <published>2022-11-11T12:25:56.000Z</published>
    <updated>2023-01-14T04:55:46.248Z</updated>
    
    <content type="html"><![CDATA[<p>公式在同济高数七版下册第182页。</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d}x}\int_{\alpha (x)}^{\beta (x)} f(x,y)\, \mathrm{d}y=\int_{\alpha (x)}^{\beta (x)} f_{x}^{'}(x,y)\, \mathrm{d}y+f[x,\beta (x)]\beta ^{'}(x)-f[x,\alpha (x)]\alpha ^{'}(x)</script><p>不详细推导，只作几何直观的展示。</p><p><strong>NOTICE：</strong> 以下推导中，高阶无穷小忽略没有写出，因为它会在除以$\Delta x$再取极限之后变为$0$.</p><p>先考虑 $\int_{\alpha (x)}^{\beta (x)} f(x,y)\, \mathrm{d}y$ 的几何直观。现在想象一个三维的曲面$z=f(x,y)$，它也许是这样的（随便画一个）：</p><p><img src="https://s2.loli.net/2022/11/10/2tlz85oCXny3qZQ.png" alt="matlabpic.png"></p><p>固定某个选定的$x$值，取曲面$z=f(x,y)$与平面$X=x$的截线：</p><p><img src="https://bu.dusays.com/2023/01/01/63b1960bb292e.png" alt="16-2.png"></p><p>当$x$固定时，$\int_{\alpha (x)}^{\beta (x)} f(x,y)\, \mathrm{d}y$ 是从$\alpha (x)$到$\beta (x)$对$y$的定积分，在上图中它表示红色曲边梯形的面积。</p><p>上图中，红色曲线在曲面$z=f(x,y)$中，清晰起见，曲面$z=f(x,y)$没有画出。$\alpha (x)$和$\beta (x)$是 $x$ 的函数。当$x$变化时，$\alpha (x)$和$\beta (x)$ 的值会相应变化，同时，曲边梯形的形状也会跟着变化。</p><p>$\frac{\mathrm{d}}{\mathrm{d}x}\int_{\alpha (x)}^{\beta (x)} f(x,y)\, \mathrm{d}y$ 即曲边梯形面积对$x$的变化率。为此，我们考察当$x$获得一个很小的增量$\Delta x$时，曲边梯形面积将如何变化。</p><p>先考虑简单情形: $\alpha (x)$和$\beta (x)$为常函数。在此之前，简单回顾一下微分的几何意义：</p><p><img src="https://bu.dusays.com/2023/01/01/63b1960cdbe03.png" alt="16-3.png"></p><p>由此得到启发，既然现在是三维的，我们把“在局部范围内用来近似替代非线性函数的<strong>线性函数</strong>（下图中的蓝色部分）”积起来，就是曲边梯形面积的增量了。</p><p><img src="https://bu.dusays.com/2023/01/01/63b1960c567f5.png" alt="16-4.png"></p><p>它就是$\Delta x \int_{\alpha (x)}^{\beta (x)} f_{x}^{‘}(x,y)\, \mathrm{d}y$ 。问题还没解决，刚刚只是 $\alpha (x)$和$\beta (x)$ 为常函数的情形，在其他情形中，还需要考虑边界处的增量。<strong>注意：</strong> 我们考虑的是曲边梯形面积的增量，而不是什么东西的体积的增量。</p><p><img src="https://bu.dusays.com/2023/01/01/63b1960c62aad.png" alt="16-5.png"></p><p>为区分起见，上图将小矩形挪了位置。宽为$\beta ^{‘}(x) \Delta x$，高可用$f[x,\beta (x)]$替代（连续性），因此小矩形的面积为 $f[x,\beta (x)]\beta ^{‘}(x) \Delta x$ 。同理在另一处也有一个小矩形，面积为 $f[x,\alpha (x)]\alpha ^{‘}(x) \Delta x$ ,它们都是我们关注的曲边梯形面积的增量的一部分。因为积分是从$\alpha$积到$\beta$（或者从N-L公式的角度理解），$f[x,\alpha (x)]\alpha ^{‘}(x) \Delta x$ 前面需要加负号，即 $-f[x,\alpha (x)]\alpha ^{‘}(x) \Delta x$ 。</p><p>将上述所有的增量（<strong>高阶无穷小忽略没有写出</strong>）加起来，两边同除$\Delta x$，再令$\Delta x \rightarrow 0$ ，得：</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d}x}\int_{\alpha (x)}^{\beta (x)} f(x,y)\, \mathrm{d}y=\int_{\alpha (x)}^{\beta (x)} f_{x}^{'}(x,y)\, \mathrm{d}y+f[x,\beta (x)]\beta ^{'}(x)-f[x,\alpha (x)]\alpha ^{'}(x)</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;公式在同济高数七版下册第182页。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\mathrm{d}}{\mathrm{d}x}\int_{\alpha (x)}^{\beta (x)} f(x,y)\, \mathrm{</summary>
      
    
    
    
    <category term="做题" scheme="https://loveofpeach.github.io/categories/%E5%81%9A%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://loveofpeach.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>微观经济学笔记</title>
    <link href="https://loveofpeach.github.io/posts/bfc2f920.html"/>
    <id>https://loveofpeach.github.io/posts/bfc2f920.html</id>
    <published>2022-11-07T15:13:54.000Z</published>
    <updated>2023-01-22T14:47:28.199Z</updated>
    
    <content type="html"><![CDATA[<p>本文是视频 <a href="https://www.bilibili.com/video/BV1AT4y137Fp">微观经济学-中国农业大学</a> 的笔记。</p><p><img src="https://s2.loli.net/2022/11/07/iAHJGzdSeRKCumV.png" alt="Newbrush.png"></p><h2 id="经济与经济学"><a href="#经济与经济学" class="headerlink" title="经济与经济学"></a>经济与经济学</h2><p>为取得经济品的有代价的活动就是<strong>经济</strong>。</p><p><strong>经济学</strong>是研究人们如何利用<strong>稀缺资源</strong>来满足人们<strong>无限需求</strong>的一门社会科学。</p><ul><li>稀缺：相对稀缺</li><li>短缺：绝对</li><li>需求是无限的：生存（有）、享受（好）、发展（自我）</li></ul><p>经济学：解决资源的稀缺性和需求的无限性之间的矛盾。</p><h2 id="经济理论认知"><a href="#经济理论认知" class="headerlink" title="经济理论认知"></a>经济理论认知</h2><p>经济人假说：理性人、利益追求、个性追求</p><ul><li>消费者：满足最大化</li><li>生产者：利润最大化</li></ul><p>社会人：适应社会、</p><p>信息完备性假说：（。。。）</p><p>表达方法：表格法、图线法、文字描述法、数学函数法</p><p>生产可能曲线：在资源一定的情况下，所能够生产的两种商品的最大组合的运动轨迹。</p><h2 id="微观经济学的研究对象"><a href="#微观经济学的研究对象" class="headerlink" title="微观经济学的研究对象"></a>微观经济学的研究对象</h2><p>以价格为核心（价格学、资源稀缺性——价格）、以单个经济单位为研究对象（消费者，生产者）、单个经济单位的经济行为</p><p>说白了就是，解决资源的配置问题。</p><ul><li>生产什么</li><li>生产多少</li><li>为谁生产</li></ul><h2 id="怎样才能学好经济学"><a href="#怎样才能学好经济学" class="headerlink" title="怎样才能学好经济学"></a>怎样才能学好经济学</h2><p>两种研究方法：实证分析法、规范分析法</p><ul><li>实证经济学：就事论事（无价值判断）</li><li>规范经济学：就事论理（有价值判断）<ul><li>福利经济学</li><li>公共财政学</li><li>税收学</li><li>法律</li></ul></li></ul><h2 id="欲望与需求"><a href="#欲望与需求" class="headerlink" title="欲望与需求"></a>欲望与需求</h2><p>定义：需求是消费者在一定时期内，在一定价格水平上，<strong>愿意购买</strong>且<strong>能够购买</strong>的商品量。</p><ul><li>只满足一个，潜在需求</li><li>满足两个，有效需求<ul><li>有效需求=市场容量</li></ul></li></ul><h2 id="影响需求的因素"><a href="#影响需求的因素" class="headerlink" title="影响需求的因素"></a>影响需求的因素</h2><p>因素：</p><ul><li>商品本身的价格(P)</li><li>收入水平(I)<ul><li>第一类：I增Q增，正常品</li><li>第二类：I增Q减，低档品</li></ul></li><li>偏好<ul><li>引导方式：广告、宣传</li></ul></li><li>相关商品的价格<ul><li>$P_x$增，$Q_y$降$\rightarrow$互补品</li><li>$P_x$增，$Q_y$增$\rightarrow$替代品</li><li>$P_x$无论增减，$Q_y$不变$\rightarrow$独立品</li></ul></li><li>未来预期<ul><li>好：Q增加</li><li>差：Q减少</li></ul></li></ul><h2 id="需求规律及其表达"><a href="#需求规律及其表达" class="headerlink" title="需求规律及其表达"></a>需求规律及其表达</h2><p>需求规律：在其他条件不变的情况下，消费者对某种商品的需求量与商品本身的价格呈反向变化。</p><p>需求曲线以符号$D$标记。</p><p>$notice$：需求量是表示的是消费者在<strong>一定时间内</strong>的它的需求量。</p><h2 id="需求规律及其表达（2）"><a href="#需求规律及其表达（2）" class="headerlink" title="需求规律及其表达（2）"></a>需求规律及其表达（2）</h2><p>需求函数：$Q=f(p,p_x,a,c,…)$</p><ul><li>$p:$本身的价格</li><li>$p_x:$有关商品的价格</li><li>$a:$个人偏好</li><li>$c:$预期</li></ul><p>简化：$Q=f(p)$</p><ul><li>当其他条件不变时，$Q$只是$p$的函数</li></ul><p>$e.g.$<br>解释方程$Q=200-5P+2p_x$的含义</p><ul><li>解释：这种商品本身价格提高1单位，需求量减少5单位；$x$的价格提高一单位，需求量增加2单位。这里$x$是替代品。</li></ul><p>市场需求与个人需求：个人需求的加和等于市场。</p><h2 id="需求规律的例外"><a href="#需求规律的例外" class="headerlink" title="需求规律的例外"></a>需求规律的例外</h2><p>情况一：</p><p><img src="https://s2.loli.net/2022/11/07/jT9wQBqL6YlxFrM.png" alt="2dot4case1.png"></p><ul><li>例如：黄金、紧俏物资</li></ul><blockquote><p>无需广告</p></blockquote><p>情况二：</p><p><img src="https://s2.loli.net/2022/11/07/Bv6NX9O5esuwjCp.png" alt="2dot4pic2.png"></p><ul><li>例如：生活必需品(药品、食盐、收费厕所(国外居多；吐槽一下驾照考点外的扫码撒尿服务)、殡葬用品)</li></ul><blockquote><p>提价</p></blockquote><p>情况三：</p><p><img src="https://s2.loli.net/2022/11/07/F4Ul123ReSqTu7W.png" alt="2dot4pic3.png"></p><ul><li>买涨不买跌</li><li>高档消费品（奢侈品）、非生活必需品</li></ul><blockquote><p>定价宜高</p></blockquote><p>情况四：</p><p><img src="https://s2.loli.net/2022/11/07/H2WR4TFEvybg7nl.png" alt="2dot4pic4.png"></p><ul><li>金融产品</li></ul><h2 id="其他因素对需求的影响"><a href="#其他因素对需求的影响" class="headerlink" title="其他因素对需求的影响"></a>其他因素对需求的影响</h2><p>一、价格与需求</p><p><img src="https://s2.loli.net/2022/11/07/mHp8BWEK2cn7oJa.png" alt="2dot5pic1.png"></p><p>单纯由商品价格本身价格变化引起的需求量的变化，叫做<strong>需求量变动</strong>。</p><p>二、非价格因素对需求的影响</p><p>$I_1\rightarrow I_2$时，$Q_1\rightarrow Q_2\quad$  //需求变动</p><p><strong>需求变动</strong>：非价格因素变化所引起的需求量的变化。</p><p><img src="https://s2.loli.net/2022/11/07/QmqM4kz3XiePxKo.png" alt="2dot5pic2.png"></p><h2 id="产量与供给"><a href="#产量与供给" class="headerlink" title="产量与供给"></a>产量与供给</h2><p>定义：<strong>供给</strong>是生产者在一定时期内，一定的价格水平上，愿意而且能够提供的商品量。</p><ul><li>供给$\approx$出售愿望+产量<ul><li>如果只满足其中之一，称为<strong>潜在供给</strong>。</li><li>两个条件都满足，称为<strong>有效供给</strong>。</li><li>区分有效供给、潜在供给$\rightarrow$衡量生产者的实际收入</li></ul></li></ul><h2 id="影响供给的因素"><a href="#影响供给的因素" class="headerlink" title="影响供给的因素"></a>影响供给的因素</h2><ol><li>本身价格 $\quad P$增，$Q_s$增； $\quad P$减，$Q_s$减</li><li>生产成本 $\quad C$增，$Q_s$减； $\quad C$减，$Q_s$增</li><li>技术</li><li>相关商品的价格</li><li>生产者的目标<ul><li>利润最大化</li><li>总产量最大</li><li>平均产量最大</li></ul></li><li>未来预期<ul><li>好$\rightarrow Q_s$增</li><li>差$\rightarrow Q_s$减</li></ul></li></ol><h2 id="供给规律及其表达"><a href="#供给规律及其表达" class="headerlink" title="供给规律及其表达"></a>供给规律及其表达</h2><p>供给规律：在其他条件不变的情况下，某种商品的供给量与商品本身的价格呈同向变化。</p><p>供给曲线：</p><p><img src="https://s2.loli.net/2022/11/07/NhQTanfkAVOwgrY.png" alt="2dot8pic1.png"></p><p>供给函数：$Q_s=f(p,p_x,c,t,…)$</p><p>市场供给=个别供给的总和</p><h2 id="供给规律的例外"><a href="#供给规律的例外" class="headerlink" title="供给规律的例外"></a>供给规律的例外</h2><p>情况一</p><p><img src="https://s2.loli.net/2022/11/07/MJ1AGzIKPwBrfcU.png" alt="2dot9pic1.png"></p><p>例如：饮料类、某些公共产品（地铁、自来水、电力）</p><p>情况二：</p><p><img src="https://s2.loli.net/2022/11/07/M5jpqPnNb4Qz8f2.png" alt="2dot9pic2.png"></p><p>例如：土地、古玩古董</p><p>情况三：</p><p><img src="https://s2.loli.net/2022/11/07/fBnMm43HwDQuyP6.png" alt="2dot9pic3.png"></p><p>举例：流水线作业的、大规模生产的</p><p>情况四：</p><p><img src="https://s2.loli.net/2022/11/07/Tu62kwrYFRiyIsC.png" alt="2dot9pic4.png"></p><p>例如：劳动力（在上图中，$L$表示提供的劳动量，$W$表示工资）</p><h2 id="其他因素对供给的影响"><a href="#其他因素对供给的影响" class="headerlink" title="其他因素对供给的影响"></a>其他因素对供给的影响</h2><p>供给量变动：</p><p><img src="https://s2.loli.net/2022/11/07/DzSE3COImNWRqPB.png" alt="2dot10pic1.png"></p><p><strong>供给变动</strong>：非价格变化引起的</p><p><img src="https://s2.loli.net/2022/11/07/bCs91XAdRaf45BO.png" alt="2dot10pic2.png"></p><h2 id="市场均衡及其形成"><a href="#市场均衡及其形成" class="headerlink" title="市场均衡及其形成"></a>市场均衡及其形成</h2><p>均衡状态：供求力量对比的结果</p><p><img src="https://s2.loli.net/2022/11/07/x3W4tiELfYXqpAl.png" alt="2dot11pic1.png"></p><p>定义：当需求和供给相等的时候，这个状态叫均衡状态，此时的价格叫均衡价格$(P_e)$，此时的数量叫均衡数量$(Q_e)$。</p><p><img src="https://s2.loli.net/2022/11/07/K64ZGbCjOkhoVyl.png" alt="2dot11pic2.png"></p><h2 id="市场均衡的变动"><a href="#市场均衡的变动" class="headerlink" title="市场均衡的变动"></a>市场均衡的变动</h2><p>一、消费者与均衡的问题</p><p><img src="https://s2.loli.net/2022/11/07/6CeElVhcn234oRL.png" alt="2dot12pic1.png"></p><p>总结：单纯需求变动会引起均衡价格和均衡数量同向变化。</p><p>二、生产者与均衡的问题</p><p><img src="https://s2.loli.net/2022/11/07/cI6XOAqiyrN79Rm.png" alt="2dot12pic2.png"></p><p>供给变动：均衡价格反向变化；均衡数量同向变化。</p><p>三、消费者和生产者行为都在变引起的变化</p><p><img src="https://s2.loli.net/2022/11/07/5IcACwT18VavsKB.png" alt="2dot12pic3.png"></p><p>（其他情况的分析方法与之类似。。。）</p><h2 id="支持价格与限制价格"><a href="#支持价格与限制价格" class="headerlink" title="支持价格与限制价格"></a>支持价格与限制价格</h2><p>$notion:\quad$工农业产品的剪刀差</p><p><img src="https://s2.loli.net/2022/11/07/Ml4Uebq3Oj8iRZy.png" alt="2dot13pic1.png"></p><p>$definition:\quad$支持价格，政府制定的高于市场均衡价格的最低销售价格。</p><p><img src="https://s2.loli.net/2022/11/07/XzrUh1vwHIYeJKu.png" alt="2dot13pic2.png"></p><p>方法：政府收购多余商品。</p><p>$definition:\quad$限制价格，低于市场均衡价格的最高销售价。</p><p><img src="https://s2.loli.net/2022/11/07/R9OUoICN2JMWVaw.png" alt="2dot13pic3.png"></p><p>限制价格可能导致的市场现象：黑市、贿赂等。应对方法：凭票供应。</p><h2 id="政府税收"><a href="#政府税收" class="headerlink" title="政府税收"></a>政府税收</h2><p>$notion:$</p><ul><li>消费者剩余，消费者从市场里面的得益。</li><li>生产者剩余，生产者从市场里面的得益。</li></ul><p><img src="https://s2.loli.net/2022/11/07/ZwQgz1yhncE7eaU.png" alt="2dot14pic1.png"></p><p>国家收的税：$E_1A$</p><p><img src="https://s2.loli.net/2022/11/07/mSUniWtgT9yOd6B.png" alt="2dot14pic2.png"></p><p>设$A$点对应价格为$P_2$。$P_0P_1$=消费者税负，$P_0P_2$=生产者税负</p><p><img src="https://s2.loli.net/2022/11/07/VvE2XWZrs8zGdpF.png" alt="2dot14pic3.png"></p><h2 id="政府补贴"><a href="#政府补贴" class="headerlink" title="政府补贴"></a>政府补贴</h2><p><img src="https://s2.loli.net/2022/11/07/UarCBNcSWVXx7wD.png" alt="2dot15pic1.png"></p><p><img src="https://s2.loli.net/2022/11/07/a6E9yexc8uIjJpT.png" alt="2dot15pic2.png"></p><h2 id="需求价格弹性及其计算（1）"><a href="#需求价格弹性及其计算（1）" class="headerlink" title="需求价格弹性及其计算（1）"></a>需求价格弹性及其计算（1）</h2><p>一、弹性</p><script type="math/tex; mode=display">e=\frac{\frac{\Delta Y}{Y}}{\frac{\Delta X}{X}}</script><p>二、需求价格弹性</p><script type="math/tex; mode=display">e=\frac{\Delta Q/Q}{\Delta P/P}</script><p>$definition:\quad$价格变动$1\%$引起的需求量变动的百分比</p><p>$notice:\quad$在一个正常的需求曲线的计算中，为方便$(?)$起见，在公式中加一个负号，则$e$变为正。公式如下：</p><script type="math/tex; mode=display">e=-\frac{\Delta Q/Q}{\Delta P/P}</script><h2 id="需求价格弹性及其计算（2）"><a href="#需求价格弹性及其计算（2）" class="headerlink" title="需求价格弹性及其计算（2）"></a>需求价格弹性及其计算（2）</h2><p>一、点弹性</p><script type="math/tex; mode=display">e=-\frac{\Delta Q/Q}{\Delta P/P}=-\frac{\Delta Q}{\Delta P}\cdot \frac{P}{Q}=-\frac{\Delta Q}{\Delta P}\cdot \frac{P_1}{Q_1}</script><p>精确计算：</p><script type="math/tex; mode=display">e=-\lim_{\Delta P \to 0} \frac{\Delta Q}{\Delta P}\cdot \frac{P}{Q}=-\frac{P}{Q}\cdot \frac{\mathrm{d}Q}{\mathrm{d}P}</script><p>二、弧弹性</p><script type="math/tex; mode=display">e=-\frac{\Delta Q}{\Delta P}\cdot \frac{P}{Q}=-\frac{\Delta Q}{\Delta P}\cdot \frac{\frac{P_1+P_2}{2}}{\frac{Q_1+Q_2}{2}}</script><h2 id="需求价格弹性的类型"><a href="#需求价格弹性的类型" class="headerlink" title="需求价格弹性的类型"></a>需求价格弹性的类型</h2><p>情况一：</p><p><img src="https://s2.loli.net/2022/11/07/FbuEYWQJltmqLRd.png" alt="3dot2pic1.png"></p><p>情况二：</p><p><img src="https://s2.loli.net/2022/11/07/Cgq9eK6tQydPADN.png" alt="3dot2pic2.png"></p><p>情况三：</p><p><img src="https://s2.loli.net/2022/11/07/QYfIE8WDvN5xzap.png" alt="3dot2pic3.png"></p><p>例如：接近于生活必需品的</p><p>其他情况：</p><p><img src="https://s2.loli.net/2022/11/07/hC3v9K1RcqZNmEF.png" alt="3dot2pic4.png"></p><p><strong>总结：</strong></p><p><img src="https://s2.loli.net/2022/11/07/tgpdVYabc2l5XM8.png" alt="3dot2pic5.png"></p><p>$notice:\quad$同一种商品在不同价位上有不同的弹性值。高价位富有弹性，低价位缺乏弹性。</p><h2 id="影响需求价格弹性的因素"><a href="#影响需求价格弹性的因素" class="headerlink" title="影响需求价格弹性的因素"></a>影响需求价格弹性的因素</h2><p>一、商品本身被需要的程度</p><ul><li>越被需要，弹性越小</li><li>越不需要，弹性越大</li></ul><p>二、本身被替代的程度</p><ul><li>易被替代，弹性越大</li></ul><p>三、商品本身占总支出的比重</p><ul><li>比重大$\rightarrow$弹性大</li></ul><p>四、商品的用途的多少</p><ul><li>用途越多，弹性越大</li></ul><p>五、商品的种类的大小</p><ul><li>种类越大，弹性越小</li></ul><p>种类的含义如下图：</p><p><img src="https://s2.loli.net/2022/11/07/gEiQNImjXbchwPn.png" alt="3dot3pic1.png"></p><p><strong>解释</strong>：种类越小，越容易被替代，弹性就大了。</p><p>六、时间因素</p><ul><li>近期弹性小</li><li>远期弹性大</li></ul><p>解释：近期可能没有替代品；长期可能因为技术进步等原因，出现替代品。</p><h2 id="需求价格弹性的用途"><a href="#需求价格弹性的用途" class="headerlink" title="需求价格弹性的用途"></a>需求价格弹性的用途</h2><ul><li>大件$\rightarrow$价格特别关心$\rightarrow$弹性大</li></ul><p>总结：通过人们对价格的关心程度来判断。</p><ul><li>需求价格弹性就是帮助企业进行定价的</li><li>总收益（TR）=P$\cdot$Q</li></ul><p><img src="https://s2.loli.net/2022/11/07/Ke82YCrZjUIuwxB.png" alt="3dot4pic1.png"></p><p><strong>富有弹性，定低价。</strong></p><p><img src="https://s2.loli.net/2022/11/07/qzBrQcRZ6FCsYAX.png" alt="3dot4pic2.png"></p><p><strong>缺乏弹性，定高价。</strong></p><h2 id="需求收入弹性"><a href="#需求收入弹性" class="headerlink" title="需求收入弹性"></a>需求收入弹性</h2><p>$definition:\quad$消费者的收入变化1%所引起的商品需求量的变动百分比。</p><script type="math/tex; mode=display">e_I=\frac{\frac{\Delta Q}{Q}}{\frac{\Delta I}{I}}</script><p>$notion:\quad$公式前<strong>没有负号</strong></p><ul><li>$e_I&gt;0$，正常品<ul><li>$0&lt; e_I&lt;1$，必需品</li><li>$e_I&gt;1$，高档品</li></ul></li><li>$e_I&lt;0$，低档品</li></ul><p>通过$e_I$判断生活水平的高低：</p><p><img src="https://s2.loli.net/2022/11/07/WTz39FPj4o5QSEq.png" alt="3dot5pic1.png"></p><h2 id="需求交叉弹性"><a href="#需求交叉弹性" class="headerlink" title="需求交叉弹性"></a>需求交叉弹性</h2><script type="math/tex; mode=display">e_{yx}=\frac{\frac{\Delta Q_y}{Q_y}}{\frac{\Delta P_x}{P_x}}</script><p>$e_{yx}:\quad x$的价格变化引起的$y$的需求量的改变。</p><p>$notion:\quad$前面<strong>没有负号</strong>。</p><p><img src="https://s2.loli.net/2022/11/07/FgsjxMJ9w5Q8mBu.png" alt="3dot6pic1.png"></p><p>通过需求交叉弹性帮助企业调整产业结构、产品结构：</p><p><img src="https://s2.loli.net/2022/11/07/6xecVNFiIpus9R8.png" alt="3dot6pic2.png"></p><h2 id="供给弹性及其类型"><a href="#供给弹性及其类型" class="headerlink" title="供给弹性及其类型"></a>供给弹性及其类型</h2><p>$definition:\quad$供给弹性，商品的价格变化引起的供给量的变化。</p><script type="math/tex; mode=display">e_s=\frac{\frac{\Delta Q_s}{Q_s}}{\frac{\Delta P}{P}}</script><p>$notice:\quad$<strong>没有负号</strong></p><p>含义：价格变化1%引起的供给量的变动百分比</p><p>$notice:\quad$有和之前相似的<strong>点弹性</strong>、<strong>弧弹性</strong>概念</p><p>类型一：$\quad e_s=\infty \quad$完全有弹性</p><p><img src="https://s2.loli.net/2022/11/07/Yr9bWzihkp42NvC.png" alt="3dot7pic1.png"></p><p>类型二：$\quad e_s=0\quad$完全无弹性</p><p><img src="https://s2.loli.net/2022/11/07/KpQqG9dzTcyMbmj.png" alt="3dot7pic2.png"></p><p>类型三：$\quad e_s=1\quad$单位弹性</p><p>类型四：$\quad e_s&lt;1\quad$缺乏弹性</p><p>类型五：$\quad e_s&gt;1\quad$富有弹性</p><p><img src="https://s2.loli.net/2022/11/07/QTYSxcUK2zvC8gE.png" alt="3dot7pic3.png"></p><blockquote><p>影响大的弹性大，影响小的弹性小</p></blockquote><h2 id="影响供给弹性大小的因素"><a href="#影响供给弹性大小的因素" class="headerlink" title="影响供给弹性大小的因素"></a>影响供给弹性大小的因素</h2><ul><li>生产的难易程度（难$\rightarrow e_s$小）</li><li>生产成本增加幅度的大小（成本增加的幅度大$\rightarrow e_s$小）</li><li>生产规模的大小（规模大的供给弹性小）</li><li>派生供给的难易程度（易$\rightarrow e_s$大）<ul><li>$definition:$ 派生供给：对生产最终产品的原材料、机器设备、半成品和燃料等中间产品的供给。</li></ul></li><li>时间因素（现在$e_s$小，将来$e_s$大）</li></ul><h2 id="4-1-欲望与效用"><a href="#4-1-欲望与效用" class="headerlink" title="4.1 欲望与效用"></a>4.1 欲望与效用</h2><p>效用是一种对欲望的满足程度。</p><p>效用的大小和个人的经济条件是有关的。</p><h2 id="边际效用递减规律"><a href="#边际效用递减规律" class="headerlink" title="边际效用递减规律"></a>边际效用递减规律</h2><p>总效用（total utility）：消费一定量的物品获得的总满足程度</p><p>边际效用（marginal utility)：多消费一个单位的商品增加的效用值</p><script type="math/tex; mode=display">MU=\frac{\Delta TU}{\Delta Q}\quad MU=\frac{\mathrm{d}TU}{\mathrm{d}Q}</script><p>解释：增加的消费量引起的总效用的该变量。即：多消费一个产品获得的满足程度。</p><blockquote><p>满足与消费量有关。</p></blockquote><p>边际效用的加和等于总效用 $TU_x=\begin{matrix} \sum_{i=1}^n MU_{xi} \end{matrix}$</p><p><strong>边际效用递减规律</strong>：随着消费量的不断增加，后一单位的边际效用小于前一单位的边际效用。</p><h2 id="消费者最佳决策"><a href="#消费者最佳决策" class="headerlink" title="消费者最佳决策"></a>消费者最佳决策</h2><p>一、为什么要进行消费决策？</p><ul><li>收入是有限的</li><li>时间是有限的</li><li>商品是有限的</li><li>价格是变化的</li></ul><p>二、货币效应</p><script type="math/tex; mode=display">一元钱的边际效用=\frac{一单位的边际效用}{商品价格}</script><p><img src="https://s2.loli.net/2022/11/07/oku7Ycwn2tU5SzP.png" alt="4dot3pic1.png"></p><p><img src="https://s2.loli.net/2022/11/07/rjNtu2nfKBEMyhZ.png" alt="4dot3pic2.png"></p><p>总结：</p><script type="math/tex; mode=display">\begin{cases}\frac{MU_x}{P_x}=\frac{MU_y}{P_y}(最佳条件)\\P_x\cdot X+P_y\cdot Y=I(约束条件)\end{cases}</script><h2 id="消费者剩余"><a href="#消费者剩余" class="headerlink" title="消费者剩余"></a>消费者剩余</h2><p>消费者剩余=愿意支付的货币-实际支付的货币</p><ul><li>愿意支付是根据边际效用的大小来决定的。</li></ul><p><img src="https://s2.loli.net/2022/11/07/nqSoKEfPZiTdXrx.png" alt="4dot4pic1.png"></p><p>启示：</p><ul><li>政府要维持物价水平</li><li>说明发展市场经济是有好处的<ul><li>市场越发达，剩余越多</li></ul></li><li>剩余是存在的</li></ul><h2 id="消费者偏好假设与无差异曲线"><a href="#消费者偏好假设与无差异曲线" class="headerlink" title="消费者偏好假设与无差异曲线"></a>消费者偏好假设与无差异曲线</h2><p>消费者偏好：消费者对商品的喜好程度。</p><blockquote><p>消费的是商品的组合。</p></blockquote><p><strong>三个假设：</strong></p><ol><li>完全性$(completeness)$：消费者在不同的组合中能够区分(tell)，自己更偏向(喜欢)哪个组合</li><li>传递性$(transitivity)$：$a&gt;b,b&gt;c\Rightarrow a&gt;c$</li><li>非饱和性：两个不同的组合，消费者总是喜欢数量大的组合</li></ol><p>无差异曲线（等效用曲线）：</p><p><img src="https://s2.loli.net/2022/11/07/XO5UVbYATBcd6Hj.png" alt="4dot5pic1.png"></p><p>$definition:\quad$能够获得相同满足的两种商品的各种组合的运动轨迹，叫做<strong>无差异曲线</strong>。</p><p>特点：</p><ul><li>无数条。每一条无差异曲线代表唯一的效用水平；位置越高的线代表的效用水平越大。</li><li>任意两条无差异曲线不相交。</li><li>无差异曲线凸向原点。</li></ul><p>一些特例：</p><p><img src="https://s2.loli.net/2022/11/07/NZKCyBV3vrAOqeY.png" alt="4dot5pic2.png"></p><p><img src="https://s2.loli.net/2022/11/07/FNzcb75Rom3wgls.png" alt="4dot5pic3.png"></p><h2 id="预算约束线"><a href="#预算约束线" class="headerlink" title="预算约束线"></a>预算约束线</h2><p>$definition\quad$<strong>预算约束线</strong>：在收入一定的情况下，消费者所能购买的两种商品的<strong>最大</strong>组合的运动轨迹。</p><p><img src="https://s2.loli.net/2022/11/07/eZpx3EVrfkcl2CJ.png" alt="4dot6pic1.png"></p><p>影响因素：</p><ul><li>收入$I$</li><li>价格</li></ul><p><img src="https://s2.loli.net/2022/11/07/sUjyEuAJnedYc9p.png" alt="4dot6pic2.png"></p><p>边际替代率：$MRS_{xy}=\frac{\Delta Y}{\Delta X}$</p><ul><li>指标越大，说明替代越容易</li><li>指标越小，说明替代越难</li><li>边际替代率递减</li></ul><p><img src="https://s2.loli.net/2022/11/07/MkyLaVCqu7ZwsdO.png" alt="4dot6pic3.png"></p><p>证明：</p><p><img src="https://s2.loli.net/2022/11/07/PubljBdtZgo3YsC.png" alt="4dot6pic4.png"></p><h2 id="消费者均衡"><a href="#消费者均衡" class="headerlink" title="消费者均衡"></a>消费者均衡</h2><p>消费者最佳选择问题又称<strong>消费者均衡</strong>。</p><p><img src="https://s2.loli.net/2022/11/07/jeIx3VlvDpOKS4L.png" alt="4dot7pic1.png"></p><p>$definition\quad$ 在收入一定情况下，消费者所买到的能够使效用最大的商品组合，就叫做<strong>消费者均衡</strong>。</p><p>E点的条件：（其中包含一些简单的推导，如果忘记不会可以看视频）</p><p><img src="https://s2.loli.net/2022/11/07/HYniWSXImFVo6xe.png" alt="4dot7pic2.png"></p><p>（和之前用表格推的那节课道理一样）</p><script type="math/tex; mode=display">\begin{cases}\frac{MU_x}{P_x}=\frac{MU_y}{P_y}(均衡条件)\\P_x\cdot X+P_y\cdot Y=I(约束条件)\end{cases}</script><h2 id="消费者均衡的变动"><a href="#消费者均衡的变动" class="headerlink" title="消费者均衡的变动"></a>消费者均衡的变动</h2><p>一、收入变动对消费者均衡的影响</p><p><img src="https://s2.loli.net/2022/11/07/zc8TemMR3yXFb6s.png" alt="4dot8pic1.png"></p><p>$definition\quad$ 收入改变引起的消费者的均衡变动的运动轨迹叫做<strong>收入——消费线</strong>。</p><p><strong>恩格尔曲线：</strong></p><p><img src="https://s2.loli.net/2022/11/07/2JTflcnoSiyDj91.png" alt="4dot8pic2.png"></p><p>二、价格变动对消费者均衡的影响</p><p>研究的假设：$I_0,P_y$ 不变，$P_x$ 变化</p><p><img src="https://s2.loli.net/2022/11/07/hFSo7lGBRaOc2uN.png" alt="4dot8pic3.png"></p><p>$definition\quad$ 收入不变的情况下，由于价格变化所引起的消费者的均衡位置的移动轨迹，就是<strong>价格消费曲线</strong>。</p><p><img src="https://s2.loli.net/2022/11/07/DkQOG4aPUx2Ev87.png" alt="4dot8pic4.png"></p><h2 id="替代效应与收入效应"><a href="#替代效应与收入效应" class="headerlink" title="替代效应与收入效应"></a>替代效应与收入效应</h2><p><img src="https://s2.loli.net/2022/11/07/aChBSw5qR7WDp1G.png" alt="4dot9pic1.png"></p><p>$definition\quad$ 相对价格的变化导致了产品的替代，影响了消费者的需求，叫<strong>替代效应</strong>。</p><p>$definition\quad$ 由于价格变化导致了实际收入的改变，引起了消费者需求改变，叫<strong>收入效应</strong>。</p><p>总效应=替代效应+收入效应</p><p>向政府提供建议：</p><ul><li>替代效应&lt;收入效应：要提高收入</li><li>替代效应&gt;收入效应：调整比价关系</li></ul><h2 id="生产与生产函数"><a href="#生产与生产函数" class="headerlink" title="生产与生产函数"></a>生产与生产函数</h2><p><strong>生产</strong>就是将投入要素转化为产出的活动。</p><p>生产要素：劳动、土地、资本、才能</p><p>产出：有形产品——实体、无形产品——劳务（第三产业）</p><p>$definition\quad$ <strong>生产函数：</strong> 在一定时期内，在技术水平不变的情况下，生产中所使用的各种生产要素与所能生产的最大产量之间的关系。</p><script type="math/tex; mode=display">Q=f(L,K,D)</script><blockquote><p>L劳动、K资本、D土地</p></blockquote><p><strong>柯布$\cdot$道格拉斯生产函数</strong></p><script type="math/tex; mode=display">Q=AL^{\alpha}K^{\beta}</script><p>A：技术进步因素（所有的其他说不清楚的影响因素的集合）</p><p><strong>不变要素和可变要素</strong>：</p><ul><li>不变要素（variable input）：不随着产量变化而变化的要素</li><li>可变要素（fixed input）：随着产量变化而变化的要素</li></ul><p><strong>短期生产和长期生产</strong>：</p><ul><li>短期生产（short run）：在这个时期内，至少有一种不变要素的生产</li><li>长期生产（long run）：在这个时期内，所有要素都是可变的</li></ul><h2 id="短期生产分析"><a href="#短期生产分析" class="headerlink" title="短期生产分析"></a>短期生产分析</h2><script type="math/tex; mode=display">Q=f(L,K_0)</script><blockquote><p>资本要素不变</p></blockquote><p><strong>三个产量指标：</strong></p><ol><li>总产量（Total Product of Labor)<br>$TP_L=Q$</li><li>平均产量（Average Product of Labor）<br>$AP_L=TP_L/L$</li><li>边际产量（Marginal Product of Labor）<br>$MP_L=\frac{\Delta TP_L}{\Delta L}=\frac{\Delta Q}{\Delta L}$</li></ol><p><img src="https://s2.loli.net/2022/11/07/LEzRxk8Mt5JG3p7.png" alt="5dot2pic1.png"></p><p>结论：</p><ul><li>这三条线都有一个最高点</li><li>当$MP_L=0$时，$TP_L$最大<ul><li>总产量等于边际产量的加和（其实就是数学上的求导和积分QAQ）</li></ul></li><li>当$MP_L$与$AP_L$相交时，$AP_L$最大</li></ul><p><strong>边际报酬递减规律：</strong></p><p>$definition\quad$ 在其他条件不变的情况下，单纯增加一种可变要素的使用量，一开始产量以递增的速度增长，然后以递减的速度增长，再继续增加该种要素的使用量，产量就会绝对的减产。这种现象称为边际报酬递减规律。</p><h2 id="生产的合理阶段"><a href="#生产的合理阶段" class="headerlink" title="生产的合理阶段"></a>生产的合理阶段</h2><p>第二阶段是合理阶段。</p><p><img src="https://s2.loli.net/2022/11/07/HKsU8XOBfDpJmai.png" alt="5dot3pic1.png"></p><p>第一阶段可能存在设备的闲置问题。</p><p>具体如何选定第二阶段的$L$值，与生产者的目标有关：</p><ul><li>平均产量最大</li><li>总产量最大</li></ul><p><strong>管理方法：</strong></p><ul><li>第一阶段：开拓市场</li><li>第二阶段：合理阶段</li><li>第三阶段：劳动过剩，浮于事，裁员</li></ul><h2 id="生产决策的工具"><a href="#生产决策的工具" class="headerlink" title="生产决策的工具"></a>生产决策的工具</h2><script type="math/tex; mode=display">Q=f(L,K)</script><p><strong>决策工具——等产量线</strong></p><p>生产同样的产量，可以采取不同的要素组合。</p><p><img src="https://s2.loli.net/2022/11/07/tEXkWKxQ47IyfZC.png" alt="5dot4pic1.png"></p><p>$definition\quad$<strong>等产量线</strong>$\quad$ 能够取得相同产量的两种要素的组合的运动轨迹</p><p>特征：</p><ul><li>有无数条等产量曲线，位置越高，产量水平越高</li><li>任意两条等产量曲线不相交</li><li>凸向原点</li></ul><p><strong>决策工具——等成本线</strong></p><script type="math/tex; mode=display">C_0=P_L\cdot L+P_K\cdot K</script><p><img src="https://s2.loli.net/2022/11/08/g17wxAOVSEGihQb.png" alt="5dot4pic2.png"></p><p>$definition\quad$等成本线$\quad$ 在成本一定的情况下，企业所能购买的两种要素的最大组合的运动轨迹</p><p><img src="https://s2.loli.net/2022/11/08/IychvAu8xCkLqaF.png" alt="5dot4pic3.png"></p><h2 id="生产的合理区域（1）"><a href="#生产的合理区域（1）" class="headerlink" title="生产的合理区域（1）"></a>生产的合理区域（1）</h2><script type="math/tex; mode=display">MRTS_{LK}=\frac{\Delta K}{\Delta L}</script><blockquote><p>T：边际技术替代率<br>LK：劳动对资本替代<br>左式读作：“劳动对资本的边际技术替代率”</p></blockquote><script type="math/tex; mode=display">\Delta Q=0=\Delta TP_L+\Delta TP_K</script><script type="math/tex; mode=display">0=MP_L\cdot \Delta L+MP_K\cdot \Delta K</script><script type="math/tex; mode=display">MRTS_{LK}=-\frac{\Delta K}{\Delta L}=\frac{MP_L}{MP_K}</script><blockquote><p>为方便起见，在前面加个负号。（搞不懂哪里方便了QAQ）</p></blockquote><p>$MP_L$下降，$MP_K$增加，所以$MRTS_{LK}$下降</p><p>结论：要素之间的替代是有限的</p><h2 id="生产的合理区域（2）"><a href="#生产的合理区域（2）" class="headerlink" title="生产的合理区域（2）"></a>生产的合理区域（2）</h2><p><img src="https://s2.loli.net/2022/11/08/lTVS4ofRrAFHhLq.png" alt="5dot5pic1.png"></p><p><img src="https://s2.loli.net/2022/11/08/ZYsyVqEUw5KiDPr.png" alt="5dot5pic2.png"></p><h2 id="生产者的最佳决策"><a href="#生产者的最佳决策" class="headerlink" title="生产者的最佳决策"></a>生产者的最佳决策</h2><p><strong>成本一定，产量决策：</strong></p><p><img src="https://s2.loli.net/2022/11/08/OlxXHFeGkTPiw23.png" alt="5dot6pic1.png"></p><p><strong>产量一定，成本决策：</strong></p><p><img src="https://s2.loli.net/2022/11/08/KsIz7AmjrBtbf9J.png" alt="5dot6pic2.png"></p><p><img src="https://s2.loli.net/2022/11/08/48cMEUtIQnpG9b2.png" alt="5dot6pic3.png"></p><blockquote><p>这里的最佳决策也可以称为<strong>生产者均衡</strong>。</p></blockquote><h2 id="生产扩展线"><a href="#生产扩展线" class="headerlink" title="生产扩展线"></a>生产扩展线</h2><p><img src="https://s2.loli.net/2022/11/08/A2Ke5q1jOtYBvhf.png" alt="5dot7pic1.png"></p><p>不同企业类型划分：</p><p><img src="https://s2.loli.net/2022/11/08/HhQFt6Xq1m78CLb.png" alt="5dot7pic2.png"></p><p>生产扩展线方程：</p><script type="math/tex; mode=display">\frac{MP_L}{P_L}=\frac{MP_K}{P_K}</script><p>为什么有些国家（企业）采取资本密集型，有些国家（企业）采取劳动密集型：</p><p><img src="https://s2.loli.net/2022/11/08/r68sC4FbHY9M1ej.png" alt="5dot7pic3.png"></p><h2 id="规模经济"><a href="#规模经济" class="headerlink" title="规模经济"></a>规模经济</h2><p>$definition\quad$规模经济$\quad$在一个生产过程当中，当所有的要素按照相同的倍数增加的时候，所表现出的产出的变化特征</p><p><strong>规模经济的三种形式（三个阶段）：</strong></p><ol><li>规模报酬递增</li><li>规模报酬不变</li><li>规模报酬递减</li></ol><p><img src="https://s2.loli.net/2022/11/08/mgLNbrZqVU3FGca.png" alt="5dot8pic1.png"></p><p>规模报酬递增的原因</p><ol><li>生产专门化</li><li>管理专门化</li><li>几何因素（重工业等）</li><li>便利条件</li></ol><p>规模报酬不变的原因：</p><ul><li>规模报酬递增的因素吸收完了，受到某种技术的限制</li></ul><p>规模报酬递减的原因：</p><ul><li>管理效率低下</li></ul><h2 id="多角度的成本"><a href="#多角度的成本" class="headerlink" title="多角度的成本"></a>多角度的成本</h2><p>在生产过程中实际发生的支出，为显性成本；在生产过程中经营者主观上感觉到的损失，为隐性成本。</p><p><img src="https://s2.loli.net/2022/11/08/gGRzl6SfiBXaLuT.png" alt="6dot1pic1.png"></p><p>$definiton\quad$ 当一种资源有多种用途时，生产者选择了收益最大的用途后，必然放弃的该资源用于其他用途所可能获得的最大收益，就是<strong>生产这种产品的机会成本</strong>。</p><p>经济成本=会计成本+机会成本</p><p><img src="https://s2.loli.net/2022/11/08/2jTF8lmdwG9qXaZ.png" alt="6dot1pic2.png"></p><h2 id="短期成本分析"><a href="#短期成本分析" class="headerlink" title="短期成本分析"></a>短期成本分析</h2><p>成本函数 $C=f(Q)$</p><p><img src="https://s2.loli.net/2022/11/08/qJgFWxGZOMmbLPR.png" alt="6dot2pic1.png"></p><p>短期总成本=短期固定成本(不变要素的花费)+短期可变成本(可变要素的花费)</p><script type="math/tex; mode=display">STC=TFC+TVC</script><p>或（明确特指短期成本）：</p><script type="math/tex; mode=display">TC=TFC+TVC</script><p><img src="https://s2.loli.net/2022/11/08/wYvR4izQGqALjTn.png" alt="6dot2pic2.png"></p><p><img src="https://s2.loli.net/2022/11/08/m2dyVquj3TgI9bA.png" alt="6dot2pic3.png"></p><h2 id="边际成本分析"><a href="#边际成本分析" class="headerlink" title="边际成本分析"></a>边际成本分析</h2><script type="math/tex; mode=display">MC=\frac{\Delta TC}{\Delta Q}</script><p><img src="https://s2.loli.net/2022/11/08/FvJjcVEXxORQbsL.png" alt="6dot3pic1.png"></p><p><img src="https://s2.loli.net/2022/11/08/7NIdKw2LxsnCoOT.png" alt="6dot3pic2.png"></p><p><img src="https://s2.loli.net/2022/11/08/uEMvOweoY8zNTpj.png" alt="6dot3pic3.png"></p><p>证明思路：</p><p>在AVC的最低点，有：</p><script type="math/tex; mode=display">AVC'=(\frac{TVC}{Q})'=0</script><script type="math/tex; mode=display">TVC'\cdot Q=TVC\cdot Q'</script><script type="math/tex; mode=display">\frac{TVC}{Q}=\frac{TVC'}{Q'}=\frac{\mathrm{d}TVC}{\mathrm{d}Q}</script><script type="math/tex; mode=display">AVC=MC</script><h2 id="长期总成本分析"><a href="#长期总成本分析" class="headerlink" title="长期总成本分析"></a>长期总成本分析</h2><p>规模与成本</p><p><img src="https://s2.loli.net/2022/11/08/McQt2rn9YsxJpiA.png" alt="6dot4pic1.png"></p><p><img src="https://s2.loli.net/2022/11/08/gUzZMAFH7WCNdL2.png" alt="6dot4pic2.png"></p><h2 id="长期平均成本与长期边际成本（1）"><a href="#长期平均成本与长期边际成本（1）" class="headerlink" title="长期平均成本与长期边际成本（1）"></a>长期平均成本与长期边际成本（1）</h2><p>长期平均成本（LAC） $\quad$ 长期边际成本（LMC）</p><script type="math/tex; mode=display">LAC=\frac{LTC}{Q}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视频此处有图画错了</span></span><br><span class="line"><span class="comment">//本笔记中只放正确的</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/08/hKSipPIoXsH9yzA.png" alt="6dot5pic1.png"></p><h2 id="长期平均成本与长期边际成本（2）"><a href="#长期平均成本与长期边际成本（2）" class="headerlink" title="长期平均成本与长期边际成本（2）"></a>长期平均成本与长期边际成本（2）</h2><script type="math/tex; mode=display">LMC=\frac{\Delta LTC}{\Delta Q}</script><p><img src="https://s2.loli.net/2022/11/08/j2VFZCUaTJu1rnp.png" alt="6dot5pic2.png"></p><p><strong>在SAC和LAC决定的这个产量水平上，SMC=LMC</strong></p><blockquote><p>从导数的角度去理解这块内容：STC的导数是SMC，LTC的导数是LMC，LTC是STC的包络线。对于任意一个给定资本规模的STC（当然也可以是给定labor规模的STC，只不过老师的视频中一直以给定资本规模为例），它和LTC在两者的切点处导数值相同。因此在对应的Q值，有：SMC=LMC</p></blockquote><p><img src="https://s2.loli.net/2022/11/08/ISwFQh4YZ7NonsV.png" alt="6dot5pic3.png"></p><p>规模经济的实质就是成本不断降低的经济。</p><h2 id="收益与利润分析（1）"><a href="#收益与利润分析（1）" class="headerlink" title="收益与利润分析（1）"></a>收益与利润分析（1）</h2><p>总收益$\quad TR=P\cdot Q$</p><p>平均收益$\quad AR=\frac{TR}{Q}=\frac{P\cdot Q}{Q}=P$</p><p>边际收益$\quad MR=\frac{\Delta TR}{\Delta Q}$</p><p><img src="https://s2.loli.net/2022/11/08/L6z9TXi8GQWs2Vo.png" alt="6dot6pic1.png"></p><p><img src="https://s2.loli.net/2022/11/08/IiASpYrabT2GJhk.png" alt="6dot6pic2.png"></p><h2 id="收益与利润分析（2）"><a href="#收益与利润分析（2）" class="headerlink" title="收益与利润分析（2）"></a>收益与利润分析（2）</h2><p>利润$\quad \pi =TR-TC$</p><p><img src="https://s2.loli.net/2022/11/08/JKIrxGzj9kXpsRu.png" alt="6dot6pic3.png"></p><blockquote><p>利润最大化的条件是边际收益等于边际成本</p></blockquote><h2 id="完全竞争的四个假设条件"><a href="#完全竞争的四个假设条件" class="headerlink" title="完全竞争的四个假设条件"></a>完全竞争的四个假设条件</h2><p>四种市场：$\quad$完全竞争$\quad$完全垄断$\quad$垄断竞争$\quad$寡头垄断</p><p>完全竞争的条件：</p><ul><li>大数假定<ul><li>有无数多生产者和消费者</li><li>完全竞争厂商没有定价权</li></ul></li><li>产品同质性<ul><li>所有同名产品都是一样的</li><li>厂商没有必要做广告</li></ul></li><li>信息完备性<ul><li>信息是公开、免费的，人们无所不知</li><li>不会出现假冒伪劣等现象</li></ul></li><li>资源完全流动性<ul><li>生产者想生产什么就生产什么</li><li>人（资源）想干什么工作就干什么工作</li><li>人口自由流动</li><li>意味着资源可以达到最佳配置</li></ul></li></ul><p>接近于完全竞争市场的：</p><p>证券市场 $\qquad$ 农产品市场</p><p><img src="https://s2.loli.net/2022/11/08/48WUiDeKcFnJBuN.png" alt="7dot1pic1.png"></p><h2 id="完全竞争厂商的短期均衡"><a href="#完全竞争厂商的短期均衡" class="headerlink" title="完全竞争厂商的短期均衡"></a>完全竞争厂商的短期均衡</h2><p><img src="https://s2.loli.net/2022/11/08/xBrQeNJzqy6g17Z.png" alt="7dot2pic1.png"></p><blockquote><p>注意：这里的利润是<strong>经济利润</strong>，只能说赚的钱比正常的利润要少。</p></blockquote><p><img src="https://s2.loli.net/2022/11/08/7JdncRvCoKbqV2H.png" alt="7dot2pic2.png"></p><blockquote><p>注意这里的小于号，它的记法是出于经济学的习惯而非数学<br>P=AVC，停产点</p></blockquote><h2 id="完全竞争的长期均衡"><a href="#完全竞争的长期均衡" class="headerlink" title="完全竞争的长期均衡"></a>完全竞争的长期均衡</h2><p><img src="https://s2.loli.net/2022/11/08/DHzlPtF6von7UVO.png" alt="7dot3pic1.png"></p><p>完全竞争厂商的长期均衡条件：</p><script type="math/tex; mode=display">MR=SMC=LMC=SAC=LAC</script><p><img src="https://s2.loli.net/2022/11/08/ZGR9Mzy34YWPJag.png" alt="7dot3pic2.png"></p><p>长期均衡是在最佳规模下的最佳产量，是一个行业长期均衡的达到的结果。</p><p>当个别厂商均衡的时候，行业未必均衡。当行业均衡的时候，整个厂商都均衡了。</p><h2 id="完全垄断市场的条件"><a href="#完全垄断市场的条件" class="headerlink" title="完全垄断市场的条件"></a>完全垄断市场的条件</h2><p>三个条件：</p><ol><li>只有一个厂商</li><li>无很近的替代品</li><li><strong>其他厂商无法进入</strong>（最重要）<ul><li>政府特许</li><li>材料垄断</li><li>技术垄断</li><li>不当竞争</li></ul></li></ol><p><img src="https://s2.loli.net/2022/11/08/frz4onIhyQNWjRC.png" alt="8dot1pic1.png"></p><h2 id="完全垄断厂商的短期决策"><a href="#完全垄断厂商的短期决策" class="headerlink" title="完全垄断厂商的短期决策"></a>完全垄断厂商的短期决策</h2><p><img src="https://s2.loli.net/2022/11/08/9LNIEcfqbABuWPw.png" alt="8dot2pic1.png"></p><p><img src="https://s2.loli.net/2022/11/08/QnvObdeGP5FAUYj.png" alt="8dot2pic2.png"></p><p><img src="https://s2.loli.net/2022/11/08/xBvKgtw7QCZspUL.png" alt="8dot2pic3.png"></p><p>少数情况的应对方法：降低成本、刺激消费</p><h2 id="完全垄断厂商的长期决策"><a href="#完全垄断厂商的长期决策" class="headerlink" title="完全垄断厂商的长期决策"></a>完全垄断厂商的长期决策</h2><p><img src="https://s2.loli.net/2022/11/08/xNl92HfESkuhKWz.png" alt="8dot3pic1.png"></p><h2 id="完全垄断厂商的价格歧视"><a href="#完全垄断厂商的价格歧视" class="headerlink" title="完全垄断厂商的价格歧视"></a>完全垄断厂商的价格歧视</h2><p><strong>一级价格歧视</strong></p><ul><li>需求者少</li><li>十分了解消费者的支付能力</li><li>两次、多次收费现象</li></ul><p><img src="https://s2.loli.net/2022/11/08/pG2hyaOuZg3zrDe.png" alt="8dot4pic1.png"></p><p><strong>二级价格歧视</strong>（一部分一部分地单独定价）</p><ul><li>例如：邮政计费、电话计费</li></ul><p><strong>三级价格歧视</strong>（同一个产品在不同的市场上制定不同的价格）</p><p>条件：</p><ul><li>市场之间是分割的</li><li>消费者的需求不同</li></ul><p><img src="https://s2.loli.net/2022/11/08/y8DCZzH61XsSkhW.png" alt="8dot4pic2.png"></p><h2 id="垄断竞争市场的条件"><a href="#垄断竞争市场的条件" class="headerlink" title="垄断竞争市场的条件"></a>垄断竞争市场的条件</h2><p>三个条件：</p><ol><li>有很多厂商</li><li><strong>有很近的替代品</strong> $\rightarrow$ 产品是有差别的</li><li>其他厂商自由进出</li></ol><p>整体产品的三个层次：</p><ul><li>产品的核心（功能）</li><li>产品的实体</li><li>产品的附加服务</li></ul><p><img src="https://s2.loli.net/2022/11/08/pLJkDlXbeITwRuK.png" alt="9dot1pic1.png"></p><p>垄断竞争市场竞争特别激烈</p><p><img src="https://s2.loli.net/2022/11/08/i1CXQ2vWDwFRSgM.png" alt="9dot1pic2.png"></p><h2 id="垄断竞争厂商的短期决策"><a href="#垄断竞争厂商的短期决策" class="headerlink" title="垄断竞争厂商的短期决策"></a>垄断竞争厂商的短期决策</h2><p>垄断竞争厂商达到短期决策均衡满足的条件：</p><ol><li>MR=MC</li><li>在MR=MC决定的产量上D与d相交</li></ol><p><img src="https://s2.loli.net/2022/11/08/PJuoS72Dzn1RBZ9.png" alt="9dot2pic1.png"></p><p><img src="https://s2.loli.net/2022/11/08/HftRExAPzVTkQpe.png" alt="9dot2pic2.png"></p><p>垄断竞争厂商在短期之内，不管怎样调，在市场里的份额没有增加。</p><h2 id="垄断竞争厂商的长期决策"><a href="#垄断竞争厂商的长期决策" class="headerlink" title="垄断竞争厂商的长期决策"></a>垄断竞争厂商的长期决策</h2><p><img src="https://s2.loli.net/2022/11/08/Uydt63jNeqFGL12.png" alt="9dot3pic1.png"></p><p><img src="https://s2.loli.net/2022/11/08/KXreCdG4OZRgQfk.png" alt="9dot3pic2.png"></p><p>垄断竞争长期决策的条件：</p><ol><li>MR=SMC=LMC</li><li>在MR=SMC=LMC决定的产量水平上，d线与LAC相切</li><li>D过d与LAC的切点</li></ol><p>短期决策$\rightarrow$预期变化$\qquad$长期决策$\rightarrow$份额变化</p><blockquote><p>完全竞争价格最低产量最高<br>完全垄断价格最高产量最低<br>垄断竞争居于中间</p></blockquote><h2 id="古诺模型"><a href="#古诺模型" class="headerlink" title="古诺模型"></a>古诺模型</h2><p>寡头垄断市场：只有少数几个大的厂商垄断着市场</p><p>特点：</p><ul><li>只有少数大厂商</li><li>厂商间相互影响</li><li>达成协议</li><li>价格相当稳定</li></ul><p>寡头垄断市场举例：$\quad$ 钢铁公司、化工集团</p><p><img src="https://s2.loli.net/2022/11/08/yfa6QpJGcFHIACs.png" alt="10dot1pic1.png"></p><p>古诺模型的意义：说明寡头之间是相互影响的</p><p><strong>推论：</strong> 如果有$n$个寡头，每一个寡头的产量为$Q_i= \frac{1}{n+1}\cdot Q_0$</p><h2 id="斯威齐模型"><a href="#斯威齐模型" class="headerlink" title="斯威齐模型"></a>斯威齐模型</h2><p><img src="https://s2.loli.net/2022/11/08/JEhBDMNLIOioQgs.png" alt="10dot2pic1.png"></p><p>斯威齐模型认为，寡头垄断的需求曲线<strong>有折弯</strong></p><p><img src="https://s2.loli.net/2022/11/08/sMCZVrEqzpKRcI5.png" alt="10dot2pic2.png"></p><p>寡头垄断市场中，寡头的规模也不是完全相等</p><h2 id="价格领袖制"><a href="#价格领袖制" class="headerlink" title="价格领袖制"></a>价格领袖制</h2><p>目的：确定价格、维护价格稳定</p><p>充当价格领袖的条件：</p><ul><li>成本低的企业</li><li>规模大的寡头</li></ul><p><img src="https://s2.loli.net/2022/11/08/12RhL8ysMKCJawS.png" alt="10dot3pic1.png"></p><h2 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h2><p><img src="https://s2.loli.net/2022/11/08/aDWA5nNxfYiBS3V.png" alt="10dot4pic1.png"></p><p><strong>卡特尔（cartel）：</strong> 生产者之间的价格和产量协议</p><p>卡特尔本身是个囚徒博弈的问题。</p><h2 id="智猪博弈"><a href="#智猪博弈" class="headerlink" title="智猪博弈"></a>智猪博弈</h2><p><img src="https://s2.loli.net/2022/11/08/QyeUrIp6A19Md3b.png" alt="10dot5pic1.png"></p><p>博弈矩阵：</p><!--网上找资料缝了一个表格，可能会有细节上的错误qwq--><p><style type="text/css"><br>.mytable{<br>    width: 300px;<br>    height: 200px;<br>    margin: 0 auto;<br>}</style></p><table class="mytable"><th class="row-0" style="150px;height:50px;" >    <div class="biaotou">         <div class="biaotoutxt1">小猪策略</div>         <div class="biaotoutxt2">大猪策略</div>    </div> </th> <style>    .biaotou {          line-height: 5px;        text-align: left;    }    .biaotoutxt1 {        color: #FFFFF;        padding: 1px 0 0 65px;    }    .biaotoutxt2 {        color: #FFFFF;        padding: 15px 0 0 5px;    }</style><th>按</th><th>不按</th><tr><th>按</th><th>大=+3<br>小=+1</th><th>大=+2<br>小=+4</th></tr><tr><th>不按</th><th>大=+7<br>小=-1</th><th>大=0<br>小=0</th></tr></table><p><br></p><p><strong>剔除最劣决策法</strong>，最后结果：大猪按，小猪不按</p><blockquote><p>寡头之间是相互影响的，决策是相互依赖的</p></blockquote><h2 id="生产要素市场认知"><a href="#生产要素市场认知" class="headerlink" title="生产要素市场认知"></a>生产要素市场认知</h2><p>生产者使用要素的原则：利润最大化</p><p>产品市场：</p><script type="math/tex; mode=display">MR=MC</script><script type="math/tex; mode=display">MP_L\cdot MR=MC\cdot MP_L</script><script type="math/tex; mode=display">\frac{\Delta Q}{\Delta L}\cdot \frac{\Delta TR}{\Delta Q}=\frac{\Delta TC}{\Delta Q} \cdot \frac{\Delta Q}{\Delta L}</script><script type="math/tex; mode=display">\frac{\Delta TR}{\Delta L}=\frac{\Delta TC}{\Delta L}</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">MRP_L=MFC_L</script><p>$notion\quad$边际收益产品（$MRP_L$） $Marginal$ $Rvenue$ $Product$</p><p>$notion\quad$边际要素成本（$MFC_L$） $Marginal$ $Factor$ $Cost$</p><p>生产当中<strong>使用要素的原则</strong>：$MRP_L=MFC_L$</p><p>在完全竞争的要素市场上，工资是一个常数。$MFC_L=W_0(工资)$</p><p><img src="https://s2.loli.net/2022/11/08/2MNwpUZcsABf5mq.png" alt="11dot1pic1.png"></p><blockquote><p>劳动量是工资的函数<br>图形解释：在上图中，因为边际收益产品和工资的单位相同，所以可以一起放在纵轴。边际收益产品先增后减，可以由其含义推得。</p></blockquote><p><img src="https://s2.loli.net/2022/11/08/JYrDnf51qZcvNGd.png" alt="11dot1pic2.png"></p><blockquote><p>粗线部分是劳动的需求曲线<br>解释：上图中的W0,W1,W2可以理解为不同的薪资水平。如果一个企业（or whatever…）的工资水平高，<strong>那就应该</strong>少雇人。在视频中，是以劳动为例来讲的，如果<strong>把横轴变成资本，纵轴变成利息，就形成了资本的需求曲线</strong>；如果<strong>把横轴变成土地，纵轴变成土地价格，就是土地的需求曲线</strong>。</p></blockquote><p>AFC：平均要素成本</p><p><img src="https://s2.loli.net/2022/11/08/HXvJ2VgASKckdoD.png" alt="11dot1pic3.png"></p><p><img src="https://s2.loli.net/2022/11/08/Nj8k62KybTCQI4O.png" alt="11dot1pic4.png"></p><p><img src="https://s2.loli.net/2022/11/08/GvRericVwA7aLfN.png" alt="11dot1pic5.png"></p><h2 id="工资的决定"><a href="#工资的决定" class="headerlink" title="工资的决定"></a>工资的决定</h2><p><img src="https://s2.loli.net/2022/11/08/IUVuKna7xcDYtMq.png" alt="11dot2pic1.png"></p><p>替代效应：$W_\uparrow \rightarrow L_\uparrow$</p><p>收入效应：$W_\uparrow \rightarrow L_\downarrow$</p><p><img src="https://s2.loli.net/2022/11/08/zDMZ9UsYlJ5SPBA.png" alt="11dot2pic2.png"></p><p>提高工资水平的策略：</p><ol><li>需求：<ul><li>提高生产率</li><li>支持涨价</li><li>贸易保护</li></ul></li><li>供给：（减少供给）<ul><li>对移民的限制</li><li>最长工作时间立法</li><li>规定工作的年龄</li><li>禁止使用童工</li><li>强制退休</li><li>制定最低工资法</li></ul></li></ol><h2 id="利息的决定与变动"><a href="#利息的决定与变动" class="headerlink" title="利息的决定与变动"></a>利息的决定与变动</h2><p>$notion\quad$迂回生产论</p><p><img src="https://s2.loli.net/2022/11/08/XMnGpKQiNuoB8cH.png" alt="11dot3pic1.png"></p><p>宽松政策：供给增加，利率下调</p><p>紧缩政策：供给减少，利率上调</p><h2 id="地租的决定"><a href="#地租的决定" class="headerlink" title="地租的决定"></a>地租的决定</h2><script type="math/tex; mode=display">土地价格=\frac{地租(或土地的收入)}{(银行)利率}</script><p><img src="https://s2.loli.net/2022/11/08/lfb3WKXzqSDFGkO.png" alt="11dot4pic1.png"></p><p>准地租（经济地租）：固定资产在短期内获得的报酬</p><script type="math/tex; mode=display">\begin{alignedat}{2}准地租&=固定成本+经济利润 \\     &= \pi +TFC \\\end{alignedat}</script><p><img src="https://s2.loli.net/2022/11/08/myNXLUGR7SFuIO2.png" alt="11dot4pic2.png"></p><p><img src="https://s2.loli.net/2022/11/08/lMqW62d5porfnyw.png" alt="11dot4pic3.png"></p><script type="math/tex; mode=display">\begin{aligned}\int_{0}^{Q_0}(P_0-MC)\,{\rm d}Q &= \int_{0}^{Q_0}P_0\,{\rm d}Q-\int_{0}^{Q_0}MC\,{\rm d}Q \\&= \int_{0}^{Q_0}P_0\,{\rm d}Q-(TC-TFC) \\&= (\int_{0}^{Q_0}P_0\,{\rm d}Q-TC)+TFC \\&= (TR-AVC\cdot Q_0)+TFC\\&= \pi +TFC\end{aligned}</script><script type="math/tex; mode=display">生产者剩余=\pi +TFC</script><p>寻租行为</p><p><img src="https://s2.loli.net/2022/11/08/LvRXmPIMfyYkcNU.png" alt="11dot4pic4.png"></p><h2 id="社会福利及其衡量"><a href="#社会福利及其衡量" class="headerlink" title="社会福利及其衡量"></a>社会福利及其衡量</h2><p><strong>个人福利</strong>是人们的欲望和需要所得到的满足。</p><p><strong>社会福利</strong>是个人福利的总和。</p><p><strong>经济福利</strong>是可以直接或间接用货币衡量的社会福利；<strong>非经济福利</strong>是不能用货币衡量的社会福利。</p><p>对社会福利的研究属于<strong>规范性</strong>的研究。</p><p><strong>帕累托效率</strong>指的是这样一种情况：这时经济已不可能通过改变资源配置，在其他人（至少1人）的效用水平至少不降的情况下，使任何别人（至少1人）的效用水平有所提高。</p><script type="math/tex; mode=display">帕累托无效率 \stackrel{帕累托改进}{\longrightarrow}帕累托效率</script><p>表现：</p><ol><li>交换的帕累托效率</li><li>生产的帕累托效率</li><li>交换与生产的帕累托效率</li></ol><p><img src="https://s2.loli.net/2022/11/08/xcW84nHKuMCOvgN.png" alt="12dot1pic1.png"></p><blockquote><p>交换的帕累托效率<br>解释：A的$MRS_{xy}$大于B，意味着在资源有限的前提下，应当根据贪心的策略将X优先配给A，将Y配给B。由边际效用的规律知，A和B两者的$MRS$值最终会趋于相等。这就是帕累托改进的过程在数值上的表现。</p></blockquote><p><img src="https://s2.loli.net/2022/11/08/4hiuH52DKseJG9c.png" alt="12dot1pic2.png"></p><blockquote><p>生产的帕累托效率</p></blockquote><p>$MRT_{xy}$：边际产品转化率</p><p><img src="https://s2.loli.net/2022/11/08/z4dM3HvmkX5GwJF.png" alt="12dot1pic3.png"></p><blockquote><p>MRT即是此图中的替代率</p></blockquote><p><img src="https://s2.loli.net/2022/11/08/FKHBhtvQ95GapTE.png" alt="12dot1pic4.png"></p><blockquote><p>生产与交换的帕累托效率<br>当$MRS_{xy}=MRT_{xy}$时，社会出清。</p></blockquote><h2 id="收入分配公平程度的衡量"><a href="#收入分配公平程度的衡量" class="headerlink" title="收入分配公平程度的衡量"></a>收入分配公平程度的衡量</h2><p>洛伦茨曲线</p><p><img src="https://s2.loli.net/2022/11/08/vQVUeKGFZD5Im4r.png" alt="12dot2pic1.png"></p><script type="math/tex; mode=display">基尼系数=\frac{A}{A+B}</script><p><img src="https://s2.loli.net/2022/11/08/pGir5DWC4Bnv7t9.png" alt="12dot2pic2.png"></p><ul><li>基尼系数在0.3以下，平均状态</li><li>0.3-0.4，合理状态</li><li>大于0.4，收入差距过大</li><li>大于0.6，暴发户和赤贫阶层同时出现</li></ul><h2 id="外部性及其影响"><a href="#外部性及其影响" class="headerlink" title="外部性及其影响"></a>外部性及其影响</h2><p>消费的外部性：</p><ul><li>正外部性：消费者的消费为其他消费者带来的利益</li><li>负外部性：消费者为其他消费者带来的损害</li></ul><p>生产的外部性：</p><ul><li>正外部性：（例如）养蜜蜂、行业经济</li><li>负外部性：（例如）环境污染</li></ul><blockquote><p>解决生产的负外部性：明确产权、 . . .</p></blockquote><h2 id="信息不完全性"><a href="#信息不完全性" class="headerlink" title="信息不完全性"></a>信息不完全性</h2><p>次品市场和逆向选择$\quad$错误选择（逆向选择）</p><p>信息不对称的情况下，可能产生道德风险。</p><blockquote><p>在市场经济当中，存在市场的失灵。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>祝大家考试稳过，生活愉（$y\grave{u}$）快，阖家欢乐（$l\grave{u}o$）！</p><script type="math/tex; mode=display">\mathcal{THE}\quad \mathcal{END}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是视频 &lt;a href=&quot;https://www.bilibili.com/video/BV1AT4y137Fp&quot;&gt;微观经济学-中国农业大学&lt;/a&gt; 的笔记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/07/iAHJGzd</summary>
      
    
    
    
    <category term="笔记" scheme="https://loveofpeach.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="经济" scheme="https://loveofpeach.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>英语错题集</title>
    <link href="https://loveofpeach.github.io/posts/e69d6a3b.html"/>
    <id>https://loveofpeach.github.io/posts/e69d6a3b.html</id>
    <published>2022-10-17T01:52:57.000Z</published>
    <updated>2023-01-22T14:46:17.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sentence"><a href="#Sentence" class="headerlink" title="Sentence"></a>Sentence</h2><p>Swithing to a seven-hour workday paid off: output went up. In addition, the staff, many of <strong>whom</strong> have been with the company for decades, appreciated getting home earlier.</p><p>The refuge farm itself is actually a nonprofit organization, <strong>one</strong> aiding survivors of drug and alcohol addiction, violence and other horrible experience.</p><p>Competed in 1891, in <strong>what</strong> was known as <em>The Gilded Age</em>, the five-story mansion is now owned by a famous actor who decides to stage a special production of Shakespeare’s <em>Hamlet</em>.</p><p>-We are looking for somebody who is fluent in Spanish. -No problem. I <strong>studied</strong> Spanish for four years at college.</p><p>I hope that we will be able to make it through the tough times and back to the business of working together <strong>on</strong> <strong>behalf</strong> <strong>of</strong> our common goals.</p><p>The laptops made by our company sell best, but nobody could have guessed the place in the market that they <strong>were</strong> <strong>to</strong> <strong>have</strong> 20 years ago.</p><p>In my driving lesson, a traffic rule that impressed me most is that in on time <strong>all</strong> <strong>vehicles</strong> <strong>should</strong> <strong>stop</strong> when the traffic lights turn red.</p><p><strong>Intending</strong> the concert to raise money for hunger relief and to make the public aware of the problem, Geldof invited many famous musicians to take part in  it.</p><p>Whether to favor urban development or the preservation of historical sites is especially controversial in China, where there exists rich history, diversified tradition and cultural <strong>deposits</strong>.(沉积物)</p><p><strong>Had</strong>  <strong>it</strong> <strong>not</strong> <strong>been</strong> for the timely investment from the outside, this company would not be so thriving as it is.</p><p>She <strong>had  intended</strong> to clean out the spare room last week, but it was much too occupied at that time.</p><p>Jinyong, considered one of the greatest ever kongfu fiction writers in China, built a magic land <strong>that</strong> people could escape into every now and then.</p><p><strong>Blanketed</strong>(被覆盖) in smog as winter approached, quite a lot of northen cities nationwide had to close the freeways constantly.</p><p>The regin of the next Japanese emperor will be known as “Reiwa”(令和) era, in <strong>whose</strong> name the character for “harmony” is included.</p><p>Nowadays, the Internet is a popular <strong>channel</strong>(频道；手段) for the public to access  information and voice their opinions.</p><p>The man <strong>circulating</strong> the fake news that 18 firefighters lost their lives in the explosion was arrested.</p><p>-I spent a week in Xiamen last month. -Then you must have been overcharged for sea food many a time, <strong>weren’t</strong> you? This city is known for that.</p><p>-Don’t forget to drop me a line(写信) when you settle down. -Trust me! I won’t. I’ll keep you <strong>posted</strong>.</p><p>I think that conflict is unlikely to happen, but if it <strong>were</strong> <strong>to</strong> <strong>occur</strong>, the interest of both China and the U.S. would be severely damaged.</p><p>Just tell Mike <strong>whoever</strong> has a good knowledge of physics and history is qualified for the position.</p><p>Bella, who is always cheerful, creates a friendly work atmosphere in her office every day, <strong>which</strong> her colleagues find pleasant and relaxing.</p><p>-Many optimistic teenagers owe their personalities to their outgoing parents. -It makes sense. As we all know, a happy parent <strong>makes</strong> <strong>for</strong> a happy child.</p><p>-I can’t understand why he <strong>should</strong> <strong>have</strong> <strong>been</strong> so angary. I meant no offence. -It’s typical of him to be so sensitive.</p><p>The lecture <strong>having</strong> <strong>been</strong> <strong>given</strong>, a lively question-and-answer session followed.</p><p>According to the new regulation, every employee shall be paid <strong>in</strong> <strong>proportion</strong> <strong>to</strong> their work so that productivity can be increased.</p><p>-How was the journey? -Tiring! All the seats in the train <strong>occupied</strong>, I stood all the way.</p><p>A case of suspected food poisoning in the New York has led to 6 high school students <strong>being</strong> <strong>sent</strong> to hospital.</p><p>-I wonder what makes him a good English teacher. -He <strong>served</strong> as a volunteer in the UK for two years, which helps him with his work a lot.</p><p>Despite the heavy snow outside yesterday, everybody in the company <strong>went</strong> <strong>about</strong> their daily tasks as usual.</p><p>Never say anything behind a person’s back <strong>that</strong> you wouldn’t say to his face.</p><p>Unpleasant advice is a good medicine, <strong>which</strong> tastes bitter but is good for health.</p><p>We think the Internet is one of the most important sources <strong>that</strong> we can turn to for new information.</p><p>We will only discuss such problems <strong>as</strong> have something to do with our own interests.</p><p>The great wall is the only one of the buildings on the earth <strong>that</strong> is seen from the moon.</p><p>Zhang Han has determined to go to France for further study. Therefore, <strong>whatever</strong> difficulty it is, she will try her best to make her dream come true.</p><p>Large quantities of water <strong>are needed</strong> for cooling purposes in the iron and steel making process.</p><p>Richness of nightlife is one of the standards that <strong>are  used</strong> to measure a region’s living standard.</p><p>In recent years, many a teacher at the college <strong>has</strong> abandoned teaching in favor of a career as a businessman and more than one of them <strong>has</strong> achieved success.</p><p>All I want to tell you <strong>is</strong> that all <strong>are</strong> equal before the law.</p><p>Every means <strong>has  been</strong> tried to solve the problem, but none is effective.</p><p>Many a student <strong>has</strong> been to Beijing and more than one student <strong>has</strong> ever been to the Great Wall.</p><p>Every boy and every girl in our school <strong>is</strong> required to wear their school uniforms on weekdays.</p><p>Now that the road <strong>has</strong> <strong>been</strong> <strong>completed</strong> and villagers can safely walk all the way to the bottom of the mountain without fear of injury, Mr.Zhang has started working on a second road that leads to a water spring.</p><p>Even if there was a gun in my hand and he <strong>was</strong> <strong>standing</strong> in front of me, I would not shoot him.</p><p><strong>As</strong> <strong>a</strong> <strong>rule</strong>(通常情况下), John works till six o’clock in the afternoon except weekends.</p><p>According to the timetable, the train for Shanghai <strong>leaves</strong> at seven o’clock in the morning.</p><p>-Is Wang Huan a teacher? -Yes. But she <strong>served</strong> in the army for two years.</p><p>-Where is the telephone book? -I <strong>will</strong> <strong>get</strong> it for you.</p><p>David said he would climb Mount Tai with his friends next Sunday if it <strong>didn’t</strong> <strong>rain</strong>.</p><p>The audience burst into laughter because of the <strong>slip</strong> (错误) of the tongue from the host, who said, “ Good ladies, evening and gentlemen! “</p><p>-It was the third time that Rodger <strong>had</strong> <strong>phoned</strong> me to say he had a new job. -It’s difficult to keep a young man in one job for life nowadays.</p><p>When you feel alone, just look at the spaces between your fingers, and remember that’s <strong>where</strong> my fingers fit perfectly.</p><p>Next year’s key challenges include risks in the financial area and old issues that have yet <strong>to</strong> <strong>be</strong> <strong>solved</strong>.</p><p>The application of modern technology like AI in classroom teaching increasingly received a mixed <strong>reception</strong>(欢迎) among students.</p><p>I felt like giving up. I probably <strong>would  have</strong>, but my Dad whispered,”come on! You can make it!”</p><p>“But for the fact that you <strong>studied</strong> here for 3 years, I <strong>wouldn’t</strong> <strong>be</strong> <strong>studying</strong> in this key high school now, facing its endless homework and exams!” the poor girl cried to her helpless father.</p><p>-What makes you so nervous? -The China vs Iran World Cup qualifier will <strong>kick</strong> <strong>off</strong> tonight.</p><p>Just surf the Internet and then call one <strong>of  which</strong> the telephone number is provided.</p><p>Molly finally agreed, <strong>somewhat</strong>(等价于to some degree) reluctantly, to go and see a doctor.</p><p>I know he feels upset about his failure, and I can <strong>relate</strong> <strong>to</strong>(理解) that.</p><p>The company needs to <strong>shake</strong> <strong>off</strong> its outdated image to promote its newly-released product. (shake off one’s image摆脱 $\cdots$ 的形象)</p><p>He was offered a position at the local church school, <strong>after</strong> <strong>which</strong> he went to the Cambridge.</p><p>Usually, I spend my money carefully, as I have to, <strong>given</strong> that I don’t earn that much.</p><p>-Did you tell others that I’m leaving the company soon? You heave such a big mouth ! -I am so sorry about that. It was just a <strong>slip</strong> of the tongue.</p><p>-Would you like to give me the <strong>formula</strong> for success? -Make some mistakes. That’s where you’ll find success<br> (recipe意为“食谱、方法”；receipt意为“收据、契据”)</p><p>Liza <strong>may</strong> well not want to go on the trip —- she hates traveling. (“may well”和“might well”意为“很可能”)</p><p>Morris ordered the flowers and chocolates he would present to his wife on Valentine’s Day <strong>well</strong> <strong>in</strong> <strong>advance</strong>.</p><p>“The Wandering Earth” tells a story that the world goverment decides to move Earth to a new solar system as the sun dies, but unfortunately the Earth is on an apparent <strong>collision</strong> (碰撞) course with Jupiter.</p><h2 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h2><p><strong>consensus</strong>【共识】Secondly,what would be a sufficient(足够) consensus to ground an appeal to social justice?</p><p><strong>fish  in  the  air</strong>【白费力气】</p><p><strong>sit  on  the  fence</strong>【观望.jpg】</p><p><strong>caught  red</strong> <strong>-handed</strong>【抓个现行】</p><p><strong>by  virtue  of</strong>【凭借】</p><p><strong>fat  chance</strong>【渺茫的希望/可能性】</p><p><strong>good  Samaritan</strong>【乐善好施的人】</p><p><strong>fly  off  the  handle</strong>【勃然大怒】</p><p><strong>beat  around  the  bush</strong>【拐弯抹角】</p><p><strong>pull  through</strong>【康复】</p><p><strong>efficient</strong>【高效】</p><p><strong>budget</strong>【预算】</p><p><strong>pension</strong>【退休金】</p><p><strong>on</strong> <strong>account</strong> <strong>of</strong>【由于】</p><p><strong>no  sweat</strong>【小事一桩、没问题】</p><p><strong>associate</strong>【关联】The Reserve has been in the traditional associate unit business since 1968, where reservists fly and maintain aircraft owned by the active duty.</p><p><strong>reserve</strong> 【保留】</p><p><strong>revision</strong> 【调整】Reference works, like guide books, need constant revision and sometimes replacement.</p><p><strong>get</strong> <strong>over</strong>【克服】</p><p><strong>the</strong> <strong>salt</strong> <strong>of</strong> <strong>the</strong> <strong>earth</strong>【社会中坚】</p><p><strong>a</strong> <strong>big</strong> <strong>potato</strong>【大人物】</p><p><strong>the</strong> <strong>apple</strong> <strong>of</strong> <strong>our</strong> <strong>eye</strong>【掌上明珠】</p><p><strong>pull  yourself  together</strong>【重新振作】</p><p><strong>ample</strong>【充足】</p><p><strong>trembled</strong>【颤抖的】</p><p><strong>twisted</strong>【扭曲的】</p><p><strong>send</strong> <strong>over</strong>【发送】</p><p><strong>tentative</strong>【暂时的】</p><p><strong>consistent</strong>【持续的】</p><p><strong>confidential</strong>【机密的】</p><p><strong>beauty  is  in  the  eye  of  the  beholder</strong>【情人眼里出西施】</p><p><strong>conventional</strong>【传统的】</p><p><strong>concrete</strong>【具体的】</p><p><strong>cater</strong> <strong>to</strong>【迎合】</p><p><strong>contrary</strong>【相反、对立的】</p><p><strong>abrupt</strong>【粗鲁的、突然的】</p><p><strong>object</strong> <strong>to</strong>【反对】</p><p><strong>appeal</strong> <strong>to</strong>【吸引】</p><p><strong>expect  (sb)</strong> <strong>to  do</strong> || <strong>anticipate</strong> <strong>(doing)  sth</strong></p><p><strong>a</strong> <strong>tough</strong> <strong>nut</strong>【难对付的人】</p><p><strong>our</strong> <strong>great</strong> <strong>rock</strong>【我们的支持者】</p><p><strong>bring  out</strong>【呈现(方面)】</p><p><strong>sort  out</strong>【分类；处理(问题)】</p><p><strong>on  top  of</strong>【除了】</p><p><strong>in  no  time</strong>【$Leftrightarrow$ $at  once$】(注意要与$at$ $no$ $time$区分)</p><p><strong>account</strong>【账户；描述；$cdots$】</p><p><strong>pick  up  the  pieces</strong>【收拾残局】</p><p><strong>jump  down  your  throat</strong>【训斥某人】</p><p><strong>put  out</strong>【(另)出版】</p><p><strong>phenomenon</strong>【现象】</p><p><strong>roll  out</strong>【推出；离开；$cdots$】</p><p><strong>throw  in  the  towel</strong>【认输】</p><p><strong>the</strong> <strong>best</strong> <strong>fish</strong>【好人】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sentence&quot;&gt;&lt;a href=&quot;#Sentence&quot; class=&quot;headerlink&quot; title=&quot;Sentence&quot;&gt;&lt;/a&gt;Sentence&lt;/h2&gt;&lt;p&gt;Swithing to a seven-hour workday paid off: out</summary>
      
    
    
    
    <category term="笔记" scheme="https://loveofpeach.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语" scheme="https://loveofpeach.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>AIR相关转载</title>
    <link href="https://loveofpeach.github.io/posts/55a0094f.html"/>
    <id>https://loveofpeach.github.io/posts/55a0094f.html</id>
    <published>2022-10-16T14:29:03.000Z</published>
    <updated>2023-01-01T14:42:38.926Z</updated>
    
    <content type="html"><![CDATA[<p>首先应该知道，在《AIR》的故事里，隐含着许多和日本神话、传说有关的元素。例如《鸟之诗》的歌词中有“わたつみのような强さ”（“如海神般坚强”）一句，其中的“わたつみ”当训作“绵津见神”，是神话中的海神。Summer篇里神奈母亲的称号文字“八百比丘尼”也是出自古老的人鱼传说。观铃父亲的名字“橘敬介”，也包含着一样的解释。</p><p>日本最古老的书籍《古事记》中卷，“垂仁天皇”一章中，记载着如下的故事：</p><blockquote><p>“垂仁天皇令多迟摩毛理（たじまもり），到常世之国寻找‘非时香果’（非时の香の木の実）。多迟摩毛理终于来到常世之国，采到那种果实，可是在这期间，天皇已经死了。多迟摩毛理在墓前号啕大哭，终于痛哭而死。这种‘非时香果’，就是现在的橘。”</p></blockquote><p>所谓“常世之国”，就像浦岛太郎故事里的龙宫那样，是“超越了时间的世界”，换言之，“在大海彼方的永恒世界”。而且，“非时香果（非时の香の木の実）”，也就是“永远散发香气的树木所结的果实”的意思。</p><p>由上，“橘敬介”这个名字，可以解读为“尊敬橘——‘非时香果’的人”（「非时の香の木の実を」敬う人），即“寻找‘非时香果’的人”（非时の香の木の実を求める人）——也就是“寻找‘常世之国’(‘永恒的世界’)的人”（常世の国（永远の世界）を求める人）。但问题在于，“寻找‘非时香果’的人”，或称“寻找‘常世之国’的人”，和《AIR》之间又有什么关系呢？</p><p>在Summer篇“空梦”一节里，知德对柳也和里叶说过这样的话：</p><blockquote><p>知德：“对统治者来说，可以到达神身边的羽翼是不需要的东西。这样的话，所有的文书都可以修改了吧。将空作海、将鸟作鱼、将火作水，都可以这么互换过来……”<br>柳也：“（前略）正因如此，朝廷害怕翼人作为传说流传下来，会把关于翼人的一切都巧妙地隐藏起来，焚烧、修改书籍，抹杀我们的存在吧。”</p></blockquote><p>《古事记》成书于公元712年，而当时是995年；这两段对话暗示着，当时那些古文书中的“空”字后来已被置换成了“海”字；所以，对“常世之国”的解释——“在大海彼方的永恒世界”，原本很可能是“在天空彼方的永恒世界”。</p><p>《AIR》中“永恒的世界”一语出现得很少，但我认为《AIR》中的“无限”和“永恒”的意义是一样的。</p><p>AIR篇的结尾，“そら”飞向天空之前，曾有这样的一段话：</p><blockquote><p>“她已经不在这片大地上了，而是在那片天空的彼方。<br>那正是天空悲伤的原因。<br>她一直在面对着天空，<br>那片永无止境的苍穹……<br>永无终结的世界。（何も终わりを知ることもなく，続いていく世界）<br>回到那无限（その无限）中去的少女。”</p></blockquote><p>最后一句里的“那无限”所指的，自然是“永无终结”的状态，而且，“天空的彼方”也是指“永无终结的世界”。因此，“永恒”可以等同于这里的“永无终结”。</p><p>于是，“永恒”＝“永无终结”＝“无限”＝“天空的彼方”。</p><p>在《AIR》中，“天空”属于“憧憬的领域”，同时也是“过去的领域”，是“死者的领域”。在“天空中”的人，有神奈、みちる、佳乃的母亲，她们都已经逝去，观铃梦中对“空中的少女”的回忆，最后的结果也是死亡（佳乃决心到天空中去，也等于死的觉悟），等等。所以，所谓“在天空的彼方”，也就是“在（无法触及的）过去的死者的领域”。</p><p>“常世之国”＝“永恒的世界”＝“永无终结的世界”＝“无限”＝“天空的彼方”＝“（无法触及的）过去的死者的领域”，————“寻找‘常世之国’的人”＝“向往（无法触及的）过去的死者的领域的人”＝“被过去的死者束缚的人”。</p><p>很久以前，橘敬介也曾失去了自己的爱人，神尾郁子【译注：观铃的母亲，晴子的姐姐】。所以，很有可能，他正像观铃、美凪和佳乃一样，也是“被过去的死者束缚的人”。就是因为这样，所以敬介才把观铃托付给晴子，自己逃避、离开了吗？</p><p>事实上，在Air篇的8月11日，晴子和敬介之间的对话就强烈地暗示了这个意思：</p><blockquote><p>女：“我现在终于明白了……抛下这个孩子，自己逃掉的你的心情。你失去了心爱的人啊……那是你所爱的人呀。怀抱着各种回忆，共同生活过的人呀。我能理解，你失去她时的心情了。（下略）”<br>男：“你和观铃一起生活到了现在。和我不同啊。”</p></blockquote><p>根据上述理由，再考虑到Air篇的情节，“橘敬介”＝“寻找‘常世之国’的人”＝“寻找无限世界的人”＝“被过去的死者束缚的人”，这应该是合理的推论。</p><p>至于“非时”，就不需要说明了吧？“非时”就是“与时间无关”，“不知何时会结束，一直持续着”。也就是说，所谓“寻找‘非时香果’的人”，也是“寻求永远的世界的人”，是“被过去的死者所束缚的人”。多迟摩毛理的悲剧在于，他去“常世之国”寻找“橘”，等到回来的时候，物是人非，时光已经以令人吃惊的程度流逝过去了。橘敬介不是和他很像吗？他把观铃托付给晴子，自己也同样去寻求什么；但是，等到他回来的时候，观铃和晴子之间的感情已经深厚得无法分离了……</p><p>不过，最大的问题在于，Key的那些人知道多迟摩毛理的故事吗？上面这些猜测也许仅仅只是猜测而已吧……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先应该知道，在《AIR》的故事里，隐含着许多和日本神话、传说有关的元素。例如《鸟之诗》的歌词中有“わたつみのような强さ”（“如海神般坚强”）一句，其中的“わたつみ”当训作“绵津见神”，是神话中的海神。Summer篇里神奈母亲的称号文字“八百比丘尼”也是出自古老的人鱼传说。</summary>
      
    
    
    
    <category term="转载" scheme="https://loveofpeach.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="acg" scheme="https://loveofpeach.github.io/tags/acg/"/>
    
  </entry>
  
  <entry>
    <title>背包九讲</title>
    <link href="https://loveofpeach.github.io/posts/e45f505b.html"/>
    <id>https://loveofpeach.github.io/posts/e45f505b.html</id>
    <published>2022-10-16T01:58:35.000Z</published>
    <updated>2022-11-11T13:49:23.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>题目:<br>有N件物品和一个容量为V的背包。第i件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>基本思路:<br>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p><p>用子问题定义状态：即$f[i][v]$表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：$f[i][v]=max(f[i-1][v],f[i-1][v-c[i]]+w[i])$。</p><p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为$v-c[i]$的背包中”，此时能获得的最大价值就是$f[i-1][v-c[i]]$再加上通过放入第i件物品获得的价值$w[i]$。</p><p>注意$f[i][v]$有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是$f[N][V]$，而是$f[N][0..V]$的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项$f[i][v-1]$，这样就可以保证$f[N][V]$就是最后的答案。至于为什么这样就可以，由你自己来体会了。</p><p>优化空间复杂度:<br>以上方法的时间和空间复杂度均为$O(N*V)$，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到$O(V)$。</p><p>先考虑上面讲的基本思路如何实现，肯定是有一个主循环$i=1..N$，每次算出来二维数组$f[i][0..V]$的所有值。那么，如果只用一个数组$f[0..V]$，能不能保证第i次循环结束后$f[v]$中表示的就是我们定义的状态$f[i][v]$呢？$f[i][v]$是由$f[i-1][v]$和$f[i-1][v-c[i]]$两个子问题递推而来，能否保证在推$f[i][v]$时（也即在第i次主循环中推$f[v]$时）能够得到$f[i-1][v]$和$f[i-1][v -c[i]]$的值呢？事实上，这要求在每次主循环中我们以$v=V..0$的顺序推$f[v]$，这样才能保证推$f[v]$时$f[v-c[i]]$保存的是状态$f[i -1][v-c[i]]$的值。伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>其中的$f[v]=max{f[v],f[v-c[i]]}$一句恰就相当于我们的转移方程$f[i][v]=max{f[i-1][v],f[i- 1][v-c[i]]}$，因为现在的$f[v-c[i]]$就相当于原来的$f[i-1][v-c[i]]$。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了$f[i][v]$由$f[i][v-c[i]]$推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。</p><p>总结<br>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>题目:<br>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>基本思路:<br>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令$f[i][v]$表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样$f[i][v]=max{f[i-1][v-k<em>c[i]]+k</em>w[i]|0&lt;=k<em>c[i]&lt;= v}$。这跟01背包问题一样有O(N</em>V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态$f[i][v]$的时间是$O(v/c[i])$，总的复杂度是超过$O(VN)$的。</p><p>将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。</p><p>一个简单有效的优化:<br>完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足$c[i]&lt;=c[j]$且$w[i]&gt;=w[j]$，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得$j$换成物美价廉的$i$，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。</p><p>转化为01背包问题求解<br>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选$V/c[i]$件，于是可以把第i种物品转化为$V/c[i]$件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。</p><p>更高效的转化方法是：把第i种物品拆成费用为$c[i]<em>2^k$、价值为$w[i]</em>2^k$的若干件物品，其中k满足$c[i]*2^k&lt;V$。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成$O(log(V/c[i]))$件物品，是一个很大的改进。但我们有更优的O(VN)的算法。 O(VN)的算法这个算法使用一维数组，先看伪代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N <span class="keyword">for</span> v=<span class="number">0.</span>.V</span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照$v=V..0$的逆序来循环。这是因为要保证第i次循环中的状态$f[i][v]$是由状态$f[i-1][v-c[i]]$递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果$f[i-1][v-c[i]]$。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果$f[i][v-c[i]]$，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。</p><p>这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：<br>$f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}$，将这个方程用一维数组实现，便得到了上面的伪代码。</p><p>总结<br>完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“$O(VN)$的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</p><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>题目:<br>有N种物品和一个容量为V的背包。第i种物品最多有$n[i]$件可用，每件费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>基本算法:<br>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有$n[i]+1$种策略：取0件，取1件……取 $n[i]$件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：$f[i][v]=max{f[i-1][v-k<em>c[i]]+ k</em>w[i]|0&lt;=k&lt;=n[i]}$。复杂度是$O(V*∑n[i])$。</p><p>转化为01背包问题<br>另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为$∑n[i]$的01背包问题，直接求解，复杂度仍然是$O(V*∑n[i])$。</p><p>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取$0..n[i]$件——均能等价于取若干件代换以后的物品。另外，取超过$n[i]$件的策略必不能出现。</p><p>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 $1,2,4,…,2^(k-1),n[i]-2^k+1$，且k是满足$n[i]-2^k+1&gt;0$的最大整数。例如，如果$n[i]$为13，就将这种物品分成系数分别为1,2,4,6的四件物品。</p><p>分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分$0..2^{k-1}$和$2^k..n[i]$两段来分别讨论得出，并不难，希望你自己思考尝试一下。</p><p>这样就将第i种物品分成了$O(log n[i])$种物品，将原问题转化为了复杂度为$O(V*∑log n[i])$的01背包问题，是很大的改进。</p><p>$O(VN)$的算法<br>多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。</p><p>小结<br>这里我们看到了将一个算法的复杂度由$O(V<em>∑n[i])$改进到$O(V</em>∑log n[i])$的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</p><h2 id="混合三种背包问题"><a href="#混合三种背包问题" class="headerlink" title="混合三种背包问题"></a>混合三种背包问题</h2><p>问题:<br>如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？</p><p>01背包与完全背包的混合<br>考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">if</span>   <span class="comment">//第i件物品是01背包</span></span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>   <span class="comment">//第i件物品是完全背包</span></span><br><span class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>再加上多重背包<br>如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成$O(log n[i])$个01背包的物品的方法也已经很优了。</p><p>小结<br>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</p><h2 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h2><p>问题:<br>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。</p><p>算法:<br>费用加了一维，只需状态也加一维即可。设$f[i][v][u]$表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是<br>$f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}$。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用顺序的循环，当物品有如完全背包问题时采用逆序的循环。当物品有如多重背包问题时拆分物品。</p><p>物品总个数的限制<br>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设$f[v][m]$表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。</p><p>另外，如果要求“恰取M件物品”，则在f[0..V][M]范围内寻找答案。</p><p>小结:<br>事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一纬以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。</p><h2 id="分组的背包问题"><a href="#分组的背包问题" class="headerlink" title="分组的背包问题"></a>分组的背包问题</h2><p>问题:<br>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>算法<br>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设$f[k][v]$表示前$k$组物品花费费用v能取得的最大权值，则有$f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]}$。(物品i属于第k组)</p><p>使用一维数组的伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="comment">//所有的组k</span></span><br><span class="line"><span class="keyword">for</span> <span class="comment">//所有的i属于组k</span></span><br><span class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure><p>另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。</p><p>小结:<br>分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。</p><h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><p>简化的问题:<br>这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。</p><p>算法:<br>这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。</p><p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有$n$个附件，则策略有$2^{n+1}$个，为指数级。）</p><p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于P06中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</p><p>再考虑P06中的一句话：可以对每组中的物品应用P02中“一个简单有效的优化”。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为$0..V-c[i]$所有这些值时相应的最大价值$f[0..V-c[i]]$。那么这个主件及它的附件集合相当于$V-c[i]+1$个物品的物品组，其中费用为$c[i]+k$的物品的价值为$f[k]+w[i]$。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为 $V-c[i]+1$个物品的物品组，就可以直接应用P06的算法解决问题了。</p><p>更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。</p><p>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。</p><p>事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。</p><p>小结:<br>NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。</p><p>我想说：失败不是什么丢人的事情，从失败中全无收获才是。</p><h2 id="泛化物品"><a href="#泛化物品" class="headerlink" title="泛化物品"></a>泛化物品</h2><p>定义:<br>考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。</p><p>更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是$h(v)$。</p><p>这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组$h[0..V]$，给它费用v，可得到价值h[V]。</p><p>一个费用为c价值为w的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为0的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当v被c整除时有h(v)=v/c<em>w，其它函数值均为0。如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有$h(v)=v/c</em>w$仅当v被c整除且$v/c&lt;=n$，其它情况函数值均为0。</p><p>一个物品组可以看作一个泛化物品h。对于一个0..V中的v，若物品组中不存在费用为v的的物品，则$h(v)=0$，否则$h(v)$为所有费用为v的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。</p><p>泛化物品的和</p><p>如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用v分配到h和l中的最大价值f(v)。也即$f(v)=max{h(k) +l(v-k)|0&lt;=k&lt;=v}$。可以看到，f也是一个由泛化物品h和l决定的定义域为0..V的函数，也就是说，f是一个由泛化物品h和 l决定的泛化物品。</p><p>由此可以定义泛化物品的和：h、l都是泛化物品，若泛化物品f满足$f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}$，则称f是h与l的和，即f=h+l。这个运算的时间复杂度是O(V^2)。</p><p>泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为s，则答案就是s[0..V]中的最大值。</p><p>背包问题的泛化物品<br>一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。</p><p>综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。</p><p>小结<br>本讲可以说都是我自己的原创思想。具体来说，是我在学习函数式编程的 $Scheme$ 语言时，用函数编程的眼光审视各类背包问题得出的理论。这一讲真的很抽象，也许在“模型的抽象程度”这一方面已经超出了NOIP的要求，所以暂且看不懂也没关系。相信随着你的OI之路逐渐延伸，有一天你会理解的。</p><p>我想说：“思考”是一个OIer最重要的品质。简单的问题，深入思考以后，也能发现更多。</p><h2 id="背包问题问法的变化"><a href="#背包问题问法的变化" class="headerlink" title="背包问题问法的变化"></a>背包问题问法的变化</h2><p>以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法，在这里值得提一下。但是我认为，只要深入理解了求背包问题最大价值的方法，即使问法变化了，也是不难想出算法的。</p><p>例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。</p><p>还有，如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。</p><p>下面说一些变化更大的问法。</p><p>输出方案<br>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。</p><p>还是以01背包为例，方程为$f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}$。再用一个数组$g[i] [v]$，设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项（也即f[i][v]=f[i-1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写（设最终状态为f[N][V]）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i=N</span><br><span class="line">v=V</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span>(g[i][v]==<span class="number">0</span>)</span><br><span class="line">print <span class="comment">//&quot;未选第i项物品&quot;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g[i][v]==<span class="number">1</span>)</span><br><span class="line">print <span class="comment">//&quot;选了第i项物品&quot;</span></span><br><span class="line">v=v-c[i]</span><br></pre></td></tr></table></figure><p>另外，采用方程的前一项或后一项也可以在输出方案的过程中根据f[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g[i] [v]==0改成$f[i][v]==f[i-1][v]$，g[i][v]==1改成f[i][v]==f[i-1][v-c[i]]+w[i]也可。</p><p>输出字典序最小的最优方案<br>这里“字典序最小”的意思是1..N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。</p><p>一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。不管答案怎样，子问题的物品都是以i..N而非前所述的1..i的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。</p><p>在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从N到1输入时，如果$f[i][v]==f[i-v]$及$f[i][v]==f[i-1][f-c[i]]+w[i]$同时成立，应该按照后者（即选择了物品i）来输出方案。</p><p>求方案总数<br>对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。</p><p>对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是01背包中的物品，转移方程即为$f[i][v]=sum{f[i-1][v],f[i-1][v-c[i]]+w[i]}$，初始条件$f[0][0]=1$。</p><p>事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。</p><p>最优方案的总数<br>这里的最优方案是指物品总价值最大的方案。还是以01背包为例。</p><p>结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求f[i][v]的同时求g[i][v]的伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</span><br><span class="line">f[i][v]=max&#123;f[i<span class="number">-1</span>][v],f[i<span class="number">-1</span>][v-c[i]]+w[i]&#125;</span><br><span class="line">g[i][v]=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(f[i][v]==f[i<span class="number">-1</span>][v])</span><br><span class="line"><span class="built_in">inc</span>(g[i][v],g[i<span class="number">-1</span>][v]</span><br><span class="line"><span class="keyword">if</span>(f[i][v]==f[i<span class="number">-1</span>][v-c[i]]+w[i])</span><br><span class="line"><span class="built_in">inc</span>(g[i][v],g[i<span class="number">-1</span>][v-c[i]])</span><br></pre></td></tr></table></figure><p>如果你是第一次看到这样的问题，请仔细体会上面的伪代码。</p><p>小结<br>显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。</p><p>触类旁通、举一反三，应该也是一个OIer应有的品质吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01背包问题&quot;&gt;&lt;a href=&quot;#01背包问题&quot; class=&quot;headerlink&quot; title=&quot;01背包问题&quot;&gt;&lt;/a&gt;01背包问题&lt;/h2&gt;&lt;p&gt;题目:&lt;br&gt;有N件物品和一个容量为V的背包。第i件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些</summary>
      
    
    
    
    <category term="转载" scheme="https://loveofpeach.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="算法" scheme="https://loveofpeach.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高考数学杂题</title>
    <link href="https://loveofpeach.github.io/posts/edb66c8e.html"/>
    <id>https://loveofpeach.github.io/posts/edb66c8e.html</id>
    <published>2022-10-15T11:10:42.000Z</published>
    <updated>2022-12-29T14:03:21.852Z</updated>
    
    <content type="html"><![CDATA[<p>以前的笔记。</p><h2 id="一些组合题"><a href="#一些组合题" class="headerlink" title="一些组合题"></a>一些组合题</h2><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>已知$(1+\dfrac{1}{2}x)^n$展开式的各项依次记为$a_1(x),a_2(x),…,a_{n+1}(x),$设函数$F(x)=\sum\limits_{k=1}^{n+1}ka_k(x)$。求证：$\forall x_1,x_2 \in [0,2],$恒有$|F(x_1)-F(x_2)|\leqslant 2^{n-1}(n+2)-1$。</p><p><strong>分析：</strong></p><p>答案中给出的解法比较繁琐，其实可以考虑用$\sum\limits$的一些化简技巧和二项式定理。</p><p>由题意 :</p><script type="math/tex; mode=display">F(x)=\sum\limits_{r=0}^n(r+1)C^r_n(\dfrac{1}{2}\ x)^r</script><p>这里把$(r+1)$展开 :</p><script type="math/tex; mode=display">F(x)=\sum\limits_{r=0}^n[rC^r_n(\dfrac{1}{2}\ x)^r+C^r_n(\dfrac{1}{2}\ x)^r]</script><script type="math/tex; mode=display">F(x)=\sum\limits_{r=1}^nrC^r_n(\dfrac{1}{2}\ x)^r+\sum\limits_{r=0}^nC^r_n(\dfrac{1}{2}\ x)^r</script><p>由二项式展开注意到$\sum\limits_{r=0}^nC^r_n(\dfrac{1}{2}\ x)^r=(1+\dfrac{1}{2}\ x)^n$，并且由于$rC^r_n=nC^{r-1}_{n-1}$，我们有: </p><script type="math/tex; mode=display">F(x)=n\sum\limits_{r=1}^nC^{r-1}_{n-1}(\dfrac{1}{2}\ x)^r+(1+\dfrac{1}{2}\ x)^n</script><p>为了配凑得到二项式展开的形式，注意到: </p><script type="math/tex; mode=display">\sum\limits_{r=1}^nC^{r-1}_{n-1}(\dfrac{1}{2}\ x)^r=\dfrac{1}{2}\ x\sum\limits_{r-1=0}^{n-1}C^{r-1}_{n-1}(\dfrac{1}{2}\ x)^{r-1}</script><p>由二项式定理继续化简：</p><script type="math/tex; mode=display">F(x)=\dfrac{1}{2}\ xn(1+\dfrac{1}{2}\ x)^{n-1}+(1+\dfrac{1}{2}\ x)^{n}</script><p>最终得到: </p><script type="math/tex; mode=display">F(x)=(1+\dfrac{1}{2}\ x)^{n-1}[\dfrac{1}{2}\ x(n+1)+1]</script><p>得到$F(x)$的表达式，根据单调性，命题成立。</p><p>另外，还有一种方法，不用求公式也可以证出来，但是很难想到。</p><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>现有一只青蛙，初始时在$\text{n}$号荷叶上。当祂某一时刻在$\text{k}$号荷叶上时，下一时刻江等概率地随机跳到$1,2,…,k$号荷叶之一上，直至跳到$\text{1}$号荷叶为止。当$\text{n=5}$时，平均一共跳了几次？</p><p><strong>分析：</strong></p><p>设这个期望为$E(n)$，即，我们期望这个蛙在$n$的时候跳$E(n)$次可以到$1$。</p><p>先考虑跳一步会怎么样：显然这只蛙可以以$1/n$的概率跳到$1-n$的任一点。那么，这之后呢？我们设第一步以$1/n$的概率跳到了$k$，<strong>之后这只蛙就要再跳$E(k)$次到终点</strong>。</p><p>得到递归方程：</p><script type="math/tex; mode=display">\begin{cases}E(n)=\dfrac{1}{n}(\sum\limits_{r=1}^nE(i)+n) \\E(1)=0\end{cases}</script><p>代入数据解之即可。</p><h3 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h3><p>已知$\text{A}$与$\text{B}$是集合$\{1,2,,3,\cdots,100 \}$的两个子集，<br>满足:$\text{A}$与$\text{B}$的元素个数相同，且$A\bigcap B=\varnothing .$若$n \in A$时，总有$2n+2 \in B.$试问：集合$A\bigcup B$中最多有多少个元素?</p><p><strong>分析：</strong></p><p>建立一个从$\text{A}$到$\text{B}$的映射:）</p><script type="math/tex; mode=display">f:x\rightarrow2x+2</script><p>因为$\forall n\in A,$都可以通过$f$映射到$B,$并且容易知道这个映射是不会产生冲突的，又因为$A\bigcap B=\varnothing,A,B$元素个数相同。所以$f$建立了一一对应的关系。</p><p>首先考虑，最小的元素是放在$A$还是放在$B$？注意到$f$是将小一点的元素变大,所以最小的元素必然放在$A$集合里面。那么这个元素的象自然在$B$里面。</p><p>反复进行这样的过程：找出未被标记的最小元素放到$A$里面，这个元素的象放到$B$里面，然后标记这两个元素。</p><h3 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h3><p>例：元旦前夕某宿舍的四位同学各写一张贺卡先集中起来，然后每人从中拿一张别人送出的贺卡，则四张贺卡的不同分配方案有多少种？</p><p><strong>分析：</strong></p><p>考虑容斥。$\text{PS:}$<a href="https://oi-wiki.org/math/inclusion-exclusion-principle/">《容斥原理》</a></p><p>由容斥的思想，多加的减回去，然后又多减了，再加回去…列出式子：</p><script type="math/tex; mode=display">A_4^4-A_3^3C_4^1+A_2^2C_4^2-A_1^1C_4^3+A_0^0C_4^4</script><p>例题解决，考虑更一般的情况：$n$个有序元素，全部改变其位置的排列数是多少？</p><p>设$f(n)$表示$n$个元素全部错位的排列数，容斥一下得到：</p><script type="math/tex; mode=display">f(n)=\sum\limits_{k=0}^n(-1)^kA_{n-k}^{n-k}C_n^k</script><p>化简之后就得到了那个公式。</p><p>另外，也可以通过动态规划得到递推关系，参考：<a href="https://www.luogu.org/blog/P6174/post-cuo-pai">小学生都能看懂的错排问题解析</a>。不过由递推式得到公式似乎并不容易，wikipedia上有较为详细的推导。</p><h2 id="一些几何题"><a href="#一些几何题" class="headerlink" title="一些几何题"></a>一些几何题</h2><h3 id="例一-1"><a href="#例一-1" class="headerlink" title="例一"></a>例一</h3><p>已知直线$y=a$交抛物线$y=x^2$于$\text{A,B}$两点，若该抛物线上存在点$\text{C,}$使得$\angle \text{ACB}$为直角，则实数$a$的取值范围是?</p><p><strong>分析：</strong></p><p>直角转化为圆相关，注意到二次函数会在远处的导数趋向于$+\infty$，但仅仅是趋向——而圆不同，圆的“左顶点”处是竖直下来的，所以如果$a$很大，绝对是可行的，所以$a$的范围一定是某个数到正无穷，找到这个特殊情况即可。</p><h3 id="例二-1"><a href="#例二-1" class="headerlink" title="例二"></a>例二</h3><p>已知椭圆$\text{C:}\dfrac{x^2}{4}+ \dfrac{y^2}{3}=1$的左右焦点分别为$F_1,F_2,$点$A$在椭圆上且满足$AF_2 \perp F_1F_2$.若$P$是椭圆上的动点，则$\overrightarrow{F_1P}\cdot \overrightarrow{F_2A}$的最大值是？</p><p><strong>分析：</strong></p><p>善用向量乘法的定义（投影那部分）可以看出答案，很多类似的题目也同理。答案是$\dfrac{3}{2} \sqrt{3}$.</p><h3 id="例三-1"><a href="#例三-1" class="headerlink" title="例三"></a>例三</h3><p>已知$A,B,C,D$四点共面$,BC=2$，$AB^2+AC^2=20,$ $\overrightarrow{CD}=3\overrightarrow{CA},$则$|\overrightarrow{BD}|$的最大值为?</p><p><strong>分析：</strong>（袋鼠角度）</p><p>由余弦定理：$AB^2+AC^2-2AB\cdot ACcosA=4$</p><p>所以$AB\cdot CDcosA=24$</p><p>${BD}^2=AB^2+\dfrac{4}{9}CD^2+\dfrac{4}{3}BA\cdot CDcosA$</p><p>即：$BD^2=AB^2+\dfrac{4}{9}CD^2+32$</p><p>又因为$AB^2+\dfrac{1}{9}CD^2=20$</p><p>所以$BD^2=52+\dfrac{1}{3}CD^2$</p><p>由三角形三边关系：$BD+2\geqslant CD$得：</p><script type="math/tex; mode=display">BD+2\geqslant \sqrt{3BD^2-52\cdot 3}</script><p>化简得：$BD^2-2BD-80\leqslant 0$</p><p>得到$BD\in[0,10],$故$BD_{max}=10$。</p><p><strong>拓展：</strong>事实上可以得到$BD \in [8,10]$。</p><h3 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h3><p>如果$\text{A}$的座標為$(1,1),F_1$是橢圓$\dfrac{x^2}{9}+\dfrac{y^2}{5}=1$的左焦點，$\text{P}$是橢圓上的動點，則$|PA|+|PF_1|$的最小值為？</p><p><strong>分析：</strong></p><p>這道簡單題放在這裡給自己提個醒：遇到圓錐曲線題不要一昧想著計算。答案是$6-\sqrt2.$</p><h3 id="例五"><a href="#例五" class="headerlink" title="例五"></a>例五</h3><p>在平面直角坐标系$xOy$中，圆$\text{C1:}(x-1)^2+y^2=2,$圆$\text{C2:}(x-m)^2+(y+m)^2=m^2,$若圆$\text{C2}$上存在点$P$满足：过点$P$向圆$\text{C1}$作两条切线$PA,PB,$切点为$A,B,\triangle ABP$的面积为$\text{1},$则正数$m$的取值范围是?</p><p><strong>分析：</strong></p><p>以下是答案的思路。</p><p>注意到$\triangle ABP$的面积是定值，从而点$P$的位置应该具有某种确定性，故首先由$\triangle ABP$的面积来确定点$P$所满足的条件，进而江问题转化为圆与圆有公共点的问题来加以处理。</p><p>设$P(x,y),$设$PA,PB$的夹角为$2\theta.$</p><p>$\triangle ABP$的面积$S=\dfrac{1}{2}PA^2sin2\theta.$</p><script type="math/tex; mode=display">S=PA^2\cdot sin\theta \cdot cos\theta</script><script type="math/tex; mode=display">S=PA^2\cdot \dfrac{\sqrt2}{PC_1}\cdot \dfrac{PA}{PC_1}=1</script><script type="math/tex; mode=display">\sqrt2 PA^3=PC_1^2=PA^2+2</script><script type="math/tex; mode=display">\therefore PA=\sqrt2,PC_1=2</script><p>$\therefore$点$P$在圆$(x-1)^2+y^2=4$上。</p><p>根据圆与圆的位置关系可知：</p><script type="math/tex; mode=display">|m-2|\leqslant \sqrt{(m-1)^2+m^2}\leqslant m+2</script><p>解得$1\leqslant m\leqslant 3+2\sqrt3$</p><h2 id="矩阵在圆锥曲线中的应用"><a href="#矩阵在圆锥曲线中的应用" class="headerlink" title="矩阵在圆锥曲线中的应用"></a>矩阵在圆锥曲线中的应用</h2><p>高二学完矩阵的时候就有这种想法，用矩阵建立一个平面点集到自身的映射，根据我的瞎猜只能方便的处理斜率相关的问题，如若涉及到长度或是角度关系用它好像不行(?)</p><p>对于椭圆$\dfrac{x^2}{a^2}+\dfrac{y^2}{b^2}=1,(a&gt;b&gt;0)$我们采用矩阵$T=\begin{pmatrix}\dfrac{b}{a}&amp;0\\0&amp;1\end{pmatrix}$建立一个平面点集到自身的映射(这里我是受到$hash$技术的启发)。同时注意到我们找到的矩阵不可以将不同的点映射到同一个点，这体现为：<strong>这个矩阵必须是可逆的。</strong></p><p>显然$T=\begin{pmatrix}\dfrac{b}{a}&amp;0\\0&amp;1\end{pmatrix}$是可逆的。<br>假设两点$A(x_1,y_1),B(x_2,y_2)$在椭圆上，则$k_{AB}=\dfrac{y_1-y_2}{x_1-x_2}$.</p><p>进行变换$T:$ $A-&gt;A^{‘},B-&gt;B^{‘}$。</p><script type="math/tex; mode=display">\begin{pmatrix}\dfrac{b}{a}&0\\0&1\end{pmatrix}A=A'=(\dfrac{bx_1}{a},y_1)</script><script type="math/tex; mode=display">\begin{pmatrix}\dfrac{b}{a}&0\\0&1\end{pmatrix}B=B'=(\dfrac{bx_2}{a},y_2)</script><p>于是得到：</p><script type="math/tex; mode=display">k_{A'B'}=\dfrac{y_1'-y_2'}{x_1'-x_2'}=\dfrac{y_1-y_2}{\dfrac{bx_1}{a}-\dfrac{bx_2}{a}}=\dfrac{a}{b}k_{AB}</script><p>找到了这两者之间的关系，就可以很方便地解决一些问题。</p><h3 id="例一-2"><a href="#例一-2" class="headerlink" title="例一"></a>例一</h3><p><img src="https://i.loli.net/2018/12/01/5c028172d01d1.png" alt="11-1"></p><p>在平面直角坐标系$xOy$中，椭圆$\text{E}:\dfrac{x^2}{a^2}+\dfrac{y^2}{b^2}=1(a&gt;b&gt;0)$的离心率为$\dfrac{\sqrt2}{2},$直线$l:y=\dfrac{1}{2}x$与椭圆$\text{E}$相交于$\text{A,B}$两点，$AB=2 \sqrt5,C,D$是椭圆$\text{E}$上异于$\text{A,B}$的两点，且直线$AC,BD$相交于点$M,$直线$AD,BC$相交于点$N$。<br>求证$MN$的斜率为定值。</p><p><strong>分析：</strong></p><p>采用上述矩阵将椭圆变换成圆之后我们发现$M’N’\perp A’B’$那么很容易得到$k_{A’B’}$,然后$k_{M’N’}$也出来了，于是就可以直接得到$k_{MN}$。</p><p><strong>Hint：使用矩阵进行映射处理椭圆，有时可以大大简化计算(有时不可以，具体情况具体分析)。特别注意在处理角度或长度问题时，此种方法不再适用。（因为不方便处理，甚至是无法解决，因为对应的方程组不可解(?)），显然，这种方法不能得全分。</strong></p><h2 id="一些函数题"><a href="#一些函数题" class="headerlink" title="一些函数题"></a>一些函数题</h2><h3 id="例一-3"><a href="#例一-3" class="headerlink" title="例一"></a>例一</h3><p>已知函数$f(x)=\dfrac{log_2x-1}{log_2x+1},$若$f(x_1)+f(2x_2)=1$(其中$x_1,x_2$均大于$2$)，则$f(x_1x_2)$的最小值为?</p><p><strong>分析：</strong>这题本不难，但是因为一些奇怪的原因没有做出来。</p><p>$\because f(x_1)+f(2x_2)=1$</p><p>$\therefore\dfrac{log_2x_1-1}{log_2x_1+1}+\dfrac{log_22x_2-1}{log_22x_2+1}=1$</p><p>$\therefore \dfrac{log_2x_1-1}{log_2x_1+1}+\dfrac{log_2x_2}{log_2x_2+2}=1$</p><p>化简得$log_2x_2=\dfrac{4}{log_2x_1-1}$</p><p>$\therefore log_2(x_1x_2)=log_2x_1+log_2x_2$</p><p>$log_2(x_1x_2)=log_2x_1+\dfrac{4}{log_2x_1-1}\geqslant 5$</p><p>当且仅当$log_2x_1=3$时等号成立。</p><p>$\therefore f(x_1x_2)=\dfrac{log_2(x_1x_2)-1}{log_2(x_1x_2)+1}$</p><p>$\therefore f(x_1x_2)=1-\dfrac{2}{log_2(x_1x_2)+1}\geqslant\dfrac{2}{3}$</p><h3 id="例二-2"><a href="#例二-2" class="headerlink" title="例二"></a>例二</h3><p>函数$f(x)=\sqrt{x-3}+ \sqrt{12-3x}$的值域为?</p><p><strong>分析(三角换元)：</strong>要注意定义域。</p><p>$D=[3,4],$则$(x-3) \in[0,1]$</p><p>令$x-3=sin^2 \theta,\theta \in [0,\dfrac{\pi}{2}],$则：</p><script type="math/tex; mode=display">f(x)=\sqrt{x-3}+\sqrt{3(4-x)}</script><script type="math/tex; mode=display">f(x)=sin \theta+ \sqrt{3(1-sin^2 \theta)}</script><script type="math/tex; mode=display">f(x)=sin \theta+ \sqrt{3}cos \theta=2sin( \theta+ \dfrac{ \pi}{3})</script><p>至此，问题已不难解决。</p><h3 id="洛必达法则的应用"><a href="#洛必达法则的应用" class="headerlink" title="洛必达法则的应用"></a>洛必达法则的应用</h3><h4 id="洛必达法则1："><a href="#洛必达法则1：" class="headerlink" title="洛必达法则1："></a>洛必达法则1：</h4><p>若(1)$\lim\limits_{x\to a(\infty)}f(x)=\lim\limits_{x\to a(\infty)}g(x)=0$；(2)在点$a$的某一邻域(不含点$a$)(或$|a|$充分大)内$f’(x),g’(x)$都存在且$g’(x)\ne 0$；(3)$\lim\limits_{x\to a(\infty)}\dfrac{f’(x)}{g’(x)}$存在(或无穷大)，则$\lim\limits_{x\to a(\infty)}\dfrac{f(x)}{g(x)}= \lim\limits_{x\to a(\infty)}\dfrac{f’(x)}{g’(x)}.$</p><h4 id="洛必达法则2："><a href="#洛必达法则2：" class="headerlink" title="洛必达法则2："></a>洛必达法则2：</h4><p>若(1)$\lim\limits_{x\to a(\infty)}f(x)=\lim\limits_{x\to a(\infty)}g(x)=\infty$；(2)在点$a$的某一邻域(不含点$a$)(或$|a|$充分大)内$f’(x),g’(x)$都存在且$g’(x)\ne 0$；(3)$\lim\limits_{x\to a(\infty)}\dfrac{f’(x)}{g’(x)}$存在(或无穷大)，则$\lim\limits_{x\to a(\infty)}\dfrac{f(x)}{g(x)}= \lim\limits_{x\to a(\infty)}\dfrac{f’(x)}{g’(x)}.$</p><h3 id="例三-2"><a href="#例三-2" class="headerlink" title="例三"></a>例三</h3><p>设函数$f(x)=x-\ln(x+\sqrt{1+x^2}).$若$x\geqslant0$时，恒有$f(x)\leqslant ax^3,$试求实数$a$的取值范围。</p><p><strong>分析：</strong></p><p>求导发现这是一个奇函数，又$f(x)$单调增。猜想$x\to0$时$(ax^3)’\geqslant f’(x).$然后洛必达：</p><script type="math/tex; mode=display">3a\geqslant \lim\limits_{\varepsilon\to0}\dfrac{1}{\varepsilon ^2}(1-\dfrac{1}{\sqrt{1+\varepsilon ^2}})</script><script type="math/tex; mode=display">\lim\limits_{\varepsilon\to0}\dfrac{1}{\varepsilon ^2}(1-\dfrac{1}{\sqrt{1+\varepsilon ^2}})=\dfrac{1}{2}</script><script type="math/tex; mode=display">\therefore a\geqslant \dfrac{1}{6}</script><p>这样就避免了分类讨论。</p><h2 id="一些不等式"><a href="#一些不等式" class="headerlink" title="一些不等式"></a>一些不等式</h2><h3 id="例一-4"><a href="#例一-4" class="headerlink" title="例一"></a>例一</h3><p>若实数$x,y$满足$2x^2+xy-y^2=1,$则$\dfrac{x-2y}{5x^2-2xy+2y^2}$的最大值为?</p><p><strong>分析：</strong></p><p>给出的条件中，独立变量有两个，因为用$x$表示$y$或用$y$表示$x$均不方便，可引入第三个变量来表示$x,y$.</p><p>首先因式分解，由$2x^2+xy-y^2=1,$得$(2x-y)(x+y)=1,$设$2x-y=t,x+y=\dfrac{1}{t},$其中$t\ne 0.$</p><p>解得：</p><script type="math/tex; mode=display">\begin{cases}x=\dfrac{1}{3}t+\dfrac{1}{3t}\\y=\dfrac{2}{3t}-\dfrac{1}{3}t\end{cases}</script><p>現在，已經轉化為一道比較常規的題了。</p><p><strong>拓展：</strong>试求$5x^2-2xy+2y^2$的最值。(hint:构造齐次式)</p><h3 id="Bernoulli不等式"><a href="#Bernoulli不等式" class="headerlink" title="Bernoulli不等式"></a>Bernoulli不等式</h3><script type="math/tex; mode=display">(1+x)^n\geqslant 1+nx(x\geqslant -1)</script><p>可以用数学归纳法证明，或许可以用于放缩。</p><h2 id="一些数列题"><a href="#一些数列题" class="headerlink" title="一些数列题"></a>一些数列题</h2><h3 id="例一-2015江苏卷"><a href="#例一-2015江苏卷" class="headerlink" title="例一 (2015江苏卷)"></a>例一 (2015江苏卷)</h3><p>设$a_1,a_2,a_3,a_4$是各项为正数且公差为$d(d\ne 0)$的等差数列。问是否存在$a_1,d$使得$a_1,a_2^2,a_3^3,a_4^4$依次构成等比数列?</p><p><strong>分析：</strong></p><p>本题主要是计算，计算没问题就行。</p><p>先假设存在。则$q=$</p><script type="math/tex; mode=display">\dfrac{(a_1+d)^2}{a_1}=\dfrac{(a_1+2d)^3}{(a_1+d)^2}=\dfrac{(a_1+3d)^4}{(a_1+2d)^3}</script><script type="math/tex; mode=display">\therefore (a_1+d)^2(a_1+3d)^4=(a_1+2d)^6</script><script type="math/tex; mode=display">\therefore d^2+9a_1d+a_1^2=0</script><p>且$(a_1+d)^2=-7a_1d.$</p><script type="math/tex; mode=display">\therefore q=-7d=\dfrac{(a_1+2d)^3}{-7a_1d}</script><p>$\mathcal{A}:$当$d&gt;0$时，易知$q&lt;0,$不成立。</p><p>$\mathcal{B}:$当$d&lt;0$时</p><script type="math/tex; mode=display">\because \dfrac{(a_1+d)^2}{a_1}=\dfrac{(a_1+2d)^3}{(a_1+d)^2}</script><script type="math/tex; mode=display">\therefore d^3=2a_1^3+4a_1d^2</script><p>显然右式大于零，左式小于零，矛盾。</p><p>综上，不存在$a_1,d$使得$a_1,a_2^2,a_3^3,a_4^4$依次构成等比数列。</p><h3 id="例二-3"><a href="#例二-3" class="headerlink" title="例二"></a>例二</h3><p>已知$\{a_n\}$是公差为$d$的等差数列，$\{b_n\}$是公比为$q$的等比数列，$q\ne1 \&amp; q\ne -1,$正整数组$E=(m,p,r)(m&lt;p&lt;r).$</p><p>问：若数组$E$中的三个数构成公差大于$1$的等差数列，且$a_m+b_p=a_p+b_r=a_r+b_m$，求$q$的最大值。</p><p><strong>分析：</strong></p><p>先用通项公式表示$b_1$,设数组$E$的公差为$d’$，然后。。。具体来讲是这样的(年代久远的混乱的草稿中硕果仅存的步骤)：</p><script type="math/tex; mode=display">\begin{cases}(p-1)d+b_1q^{r-1}=(r-1)d+b_1q^{m-1}\\(m-1)d+b_1q^{p-1}=(p-1)d+b_1q^{r-1}\end{cases}</script><script type="math/tex; mode=display">\therefore (r-m)d=b_1(q^{p-1}-q^{m-1})</script><script type="math/tex; mode=display">\therefore b_1=\dfrac{(r-m)d}{q^{p-1}-q^{m-1}}</script><p>回代到最上面的那个式子：</p><script type="math/tex; mode=display">\dfrac{q^{p-1}-q^{r-1}}{q^{p-1}-q^{m-1}}=\dfrac{p-m}{r-m}</script><script type="math/tex; mode=display">\because \begin{cases}p-m=d'\\r-m=2d'\end{cases}</script><script type="math/tex; mode=display">\dfrac{q^{d'}-q^{2d'}}{q^{d'}-1}=\dfrac{d'}{2d'}=\dfrac{1}{2}</script><p>解得$q^{d’}=-\dfrac{1}{2}$或$q^{d’}=1$（舍）</p><script type="math/tex; mode=display">\because d'>1\& d'\in Z</script><script type="math/tex; mode=display">\therefore d'_{min}=3</script><script type="math/tex; mode=display">\therefore q_{max}=\sqrt[3]{-\dfrac{1}{2}}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以前的笔记。&lt;/p&gt;
&lt;h2 id=&quot;一些组合题&quot;&gt;&lt;a href=&quot;#一些组合题&quot; class=&quot;headerlink&quot; title=&quot;一些组合题&quot;&gt;&lt;/a&gt;一些组合题&lt;/h2&gt;&lt;h3 id=&quot;例一&quot;&gt;&lt;a href=&quot;#例一&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="做题" scheme="https://loveofpeach.github.io/categories/%E5%81%9A%E9%A2%98/"/>
    
    
    <category term="数学" scheme="https://loveofpeach.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>滤镜-锐黑</title>
    <link href="https://loveofpeach.github.io/posts/c8cced9.html"/>
    <id>https://loveofpeach.github.io/posts/c8cced9.html</id>
    <published>2022-10-13T11:55:10.000Z</published>
    <updated>2022-11-06T15:25:49.963Z</updated>
    
    <content type="html"><![CDATA[<p>好，支持四通bridgeman。</p><p><img src="https://s2.loli.net/2022/10/14/cYA86SWIyeMQfiu.jpg" alt="9-1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好，支持四通bridgeman。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/10/14/cYA86SWIyeMQfiu.jpg&quot; alt=&quot;9-1.jpg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂" scheme="https://loveofpeach.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="想法" scheme="https://loveofpeach.github.io/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>板子备忘</title>
    <link href="https://loveofpeach.github.io/posts/9e22caea.html"/>
    <id>https://loveofpeach.github.io/posts/9e22caea.html</id>
    <published>2022-09-28T06:24:21.000Z</published>
    <updated>2023-01-22T14:44:21.992Z</updated>
    
    <content type="html"><![CDATA[<p>主要就是整理一下常见的算法模板，个人使用。</p><h2 id="线性筛素数"><a href="#线性筛素数" class="headerlink" title="线性筛素数"></a>线性筛素数</h2><p>给定一个范围N，你需要处理M个某数字是否为质数的询问（每个数字均在范围1-N内）</p><p>在没有读入优化的情况下，这份代码提交到洛谷上速度尚可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000100</span>;</span><br><span class="line"><span class="type">bool</span> composite[MAXN];</span><br><span class="line"><span class="type">int</span> prime[MAXN],tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    composite[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    composite[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!composite[i])prime[tail++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tail&amp;&amp;i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            composite[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,t,temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="built_in">get_prime</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(composite[temp])<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h2><blockquote><p>KMP：一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。</p></blockquote><p>对着ryf的博客思路自己写的代码实现，直观但是效率低（会超时）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tsize, ssize;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; mynext;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(std::string &amp;t)</span></span>&#123;</span><br><span class="line">    mynext.<span class="built_in">resize</span>(tsize);</span><br><span class="line">    mynext[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;tsize; i++)&#123;</span><br><span class="line">        <span class="type">int</span> k=mynext[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>((t[i] != t[k]) &amp;&amp; (k!=<span class="number">0</span>))k=mynext[k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(t[i] == t[k])mynext[i]=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> mynext[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(std::string &amp;s, std::string &amp;t, <span class="type">int</span> startpos)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = startpos, j = <span class="number">0</span>;</span><br><span class="line">    ssize = s.<span class="built_in">size</span>(), tsize = t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">getNext</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(s[i]!=t[<span class="number">0</span>])&#123;i++;&#125;</span><br><span class="line">    <span class="type">int</span> icopy = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i+tsize&lt;=ssize)&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[i]!=t[<span class="number">0</span>] &amp;&amp; i+tsize&lt;ssize)&#123;i++; icopy=i;&#125;</span><br><span class="line">        <span class="keyword">if</span>(s[icopy]==t[j])&#123;</span><br><span class="line">            icopy++, j++;</span><br><span class="line">            <span class="keyword">if</span>(j==tsize)&#123;</span><br><span class="line">                <span class="built_in">output</span>(i);</span><br><span class="line">                i += j-mynext[j<span class="number">-1</span>];</span><br><span class="line">                icopy = i; j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+tsize&gt;=ssize)<span class="keyword">return</span>;</span><br><span class="line">            i += j-mynext[j<span class="number">-1</span>];</span><br><span class="line">            icopy = i; j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s, t;</span><br><span class="line">    std::cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="built_in">kmp</span>(s, t, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = mynext.<span class="built_in">begin</span>(); i != mynext.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">        std::cout&lt;&lt;*i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交入口： <a href="https://www.luogu.com.cn/problem/P3375">https://www.luogu.com.cn/problem/P3375</a></p><p><img src="https://bu.dusays.com/2023/01/21/63cb64be3a38a.gif" alt="9-0.gif"></p><p>根据<a href="https://www.bilibili.com/video/BV1PD4y1o7nd">教学视频</a>改进的可用版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[MAXL], t[MAXL];</span><br><span class="line"><span class="type">int</span> mynext[MAXL], ssize, tsize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//题目要求下标从1开始</span></span><br><span class="line">    <span class="comment">//仅在输出时作相应处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*   需要其他形式的KMP可以由以下代码改：</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    void getNext(int* next, const string&amp; s) &#123;</span></span><br><span class="line"><span class="comment">        int j = 0;</span></span><br><span class="line"><span class="comment">        next[0] = 0;</span></span><br><span class="line"><span class="comment">        for(int i = 1; i &lt; s.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">            while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123;</span></span><br><span class="line"><span class="comment">                j = next[j - 1];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (s[i] == s[j]) &#123;</span></span><br><span class="line"><span class="comment">                j++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            next[i] = j;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int strStr(string haystack, string needle) &#123;</span></span><br><span class="line"><span class="comment">        if (needle.size() == 0) &#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int next[needle.size()];</span></span><br><span class="line"><span class="comment">        getNext(next, needle);</span></span><br><span class="line"><span class="comment">        int j = 0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; haystack.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">            while(j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;</span></span><br><span class="line"><span class="comment">                j = next[j - 1];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (haystack[i] == needle[j]) &#123;</span></span><br><span class="line"><span class="comment">                j++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (j == needle.size() ) &#123;</span></span><br><span class="line"><span class="comment">                return (i - needle.size() + 1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    mynext[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;tsize; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; t[i]!=t[j]) j=mynext[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(t[i]==t[j]) j++;</span><br><span class="line">        mynext[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmpfind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tsize)&#123;<span class="built_in">printf</span>(<span class="string">&quot;寻找内容为空串！\n&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">getNext</span>();</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ssize; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != t[j]) &#123;</span><br><span class="line">            j = mynext[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==t[j]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j==tsize) &#123;</span><br><span class="line">            <span class="built_in">output</span>(i-tsize+<span class="number">1</span>);</span><br><span class="line">            j = mynext[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s,t);</span><br><span class="line">    ssize=<span class="built_in">strlen</span>(s); tsize=<span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="comment">//本程序下标都是从0开始</span></span><br><span class="line">    <span class="built_in">kmpfind</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;tsize; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,mynext[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> uset[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeset</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)uset[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=uset[x])uset[x]=<span class="built_in">find</span>(uset[x]);</span><br><span class="line">    <span class="keyword">return</span> uset[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionset</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);</span><br><span class="line">    y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    uset[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m; cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">makeset</span>(n+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> z,x,y;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;z,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)<span class="built_in">unionset</span>(x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Y\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><blockquote><p>参考：<a href="https://blog.csdn.net/weixin_43191865/article/details/97974221">https://blog.csdn.net/weixin_43191865/article/details/97974221</a></p></blockquote><p>一些概念：</p><ul><li>结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。</li><li>树的带权路径长度为树中所有叶子结点的带权路径长度之和，通常记作<code>WPL</code>。例如下图所示的这颗树的带权路径长度为：<code>WPL=7*1+5*2+2*3+4*3</code></li></ul><p><img src="https://s2.loli.net/2022/12/18/1CwKHR7EAjt2WUM.png" alt="9-1.png"></p><p>当用n个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。在构建哈弗曼树时，只需要遵循一个原则：权重越大的结点离树根越近。</p><p>例如：3 4 5 8 ，设最后答案为ans</p><p>首先我们选3 4，合并节点，新点权值为7，并加入原序列，ans+=(3+4)</p><p><img src="https://img-blog.csdnimg.cn/20190731225807559.png" alt="9-2"></p><p>然后新序列中合并5和7，新点权值为12，ans+=(5+7)</p><p><img src="https://img-blog.csdnimg.cn/20190731225935239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE5MTg2NQ==,size_16,color_FFFFFF,t_70" alt="9-3"></p><p>最后合并12和8，新节点为20，跳出循环，ans+=(12+8)</p><p><img src="https://img-blog.csdnimg.cn/20190731230118395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE5MTg2NQ==,size_16,color_FFFFFF,t_70" alt="9-4"></p><p>最后的哈夫曼树就是右边黑色的那棵树，答案就是ans。</p><p>对于某一个节点，因为其被合并之后的值给了新的节点，而新的节点合并的时候又会加上这个值，实际上是不断为答案作贡献的。</p><p><strong>k叉哈夫曼树：</strong> 为保证其根节点可以选到k个子树，假设节点个数为n，需要满足<code>(n-1)mod(k-1)==0</code>的条件，若不满足，为原序列<code>补0</code>。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P2168">NOI2015荷马史诗</a></p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    LL w,depth;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; v)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w!=v.w) <span class="keyword">return</span> w&gt;v.w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> depth&gt;v.depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::priority_queue&lt;node&gt; qwq;</span><br><span class="line">LL n,k,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        LL tempw;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;tempw);</span><br><span class="line">        qwq.<span class="built_in">push</span>((node)&#123;tempw,<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL qwqsize = qwq.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>((qwqsize<span class="number">-1</span>)%(k<span class="number">-1</span>))&#123;</span><br><span class="line">        qwq.<span class="built_in">push</span>((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        qwqsize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(qwqsize&gt;=k)&#123;</span><br><span class="line">        LL tw = <span class="number">0</span>,tdep = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++)&#123;</span><br><span class="line">            node tq = qwq.<span class="built_in">top</span>();</span><br><span class="line">            qwq.<span class="built_in">pop</span>(); qwqsize--;</span><br><span class="line">            tdep = <span class="built_in">MAX</span>(tdep,tq.depth);</span><br><span class="line">            tw += tq.w;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += tw;</span><br><span class="line">        qwq.<span class="built_in">push</span>((node)&#123;tw,tdep+<span class="number">1</span>&#125;);</span><br><span class="line">        qwqsize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n%lld&quot;</span>,ans,qwq.<span class="built_in">top</span>().depth<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>例题：<a href="https://www.luogu.com.cn/problem/P1983">https://www.luogu.com.cn/problem/P1983</a></p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">5e7</span>+<span class="number">10</span>; <span class="comment">//算出来的空间花费远比这个多，windows会阻止运行，算错了？</span></span><br><span class="line"><span class="type">int</span> tot,head[MAXN],n,m,spot[MAXN],in[MAXN],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> v,next;&#125;edge[MAXM];</span><br><span class="line"><span class="type">bool</span> isspot[MAXN],has[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++tot].v=y;</span><br><span class="line">    edge[tot].next=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125; <span class="comment">//本题不应当采用这种存图方式，但我直接用has数组避免重构了</span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; qwq;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;    <span class="comment">//这里的toposort为适应题目做了改造</span></span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])&#123; </span><br><span class="line">            qwq.<span class="built_in">push</span>(i);</span><br><span class="line">            cnt1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!qwq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = qwq.<span class="built_in">front</span>();</span><br><span class="line">        qwq.<span class="built_in">pop</span>(); cnt1--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=edge[i].v; in[y]--;</span><br><span class="line">            <span class="keyword">if</span>(!in[y])&#123;</span><br><span class="line">                qwq.<span class="built_in">push</span>(y);</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cnt1)&#123;ans++; cnt1=cnt2; cnt2=<span class="number">0</span>;&#125;  <span class="comment">//神之一手（雾）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> s; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s);</span><br><span class="line">        <span class="built_in">memset</span>(isspot,<span class="literal">false</span>,<span class="built_in">sizeof</span>(isspot));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;spot[j]);</span><br><span class="line">            isspot[spot[j]]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=spot[<span class="number">1</span>];j&lt;=spot[s];j++)&#123; <span class="comment">//连续站点枚举</span></span><br><span class="line">            <span class="keyword">if</span>(!isspot[j])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(has[spot[k]][j])<span class="keyword">continue</span>;</span><br><span class="line">                    has[spot[k]][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">addedge</span>(spot[k],j);</span><br><span class="line">                    in[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">toposort</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>给出一个无向图，求出最小生成树，如果该图不连通，则输出orz</p><p><strong>输入格式：</strong></p><p>第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N&lt;=5000，M&lt;=200000）</p><p>接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi</p><p><strong>输出格式：</strong></p><p>输出包含一个数，即最小生成树的各边的长度之和；如果该图不连通则输出orz</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kruscal</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> u,v,w;&#125;edge[MAXM];</span><br><span class="line"><span class="type">int</span> uset[MAXN],n,m,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(uset[x]!=x)uset[x]=<span class="built_in">find</span>(uset[x]);</span><br><span class="line">    <span class="keyword">return</span> uset[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionset</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);</span><br><span class="line">    y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    uset[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge x,Edge y)</span></span>&#123;<span class="keyword">return</span> x.w&lt;y.w;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        edge[i].u=x;</span><br><span class="line">        edge[i].v=y;</span><br><span class="line">        edge[i].w=z;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)uset[i]=i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(edge[i].u);</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">find</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=edge[i].w;</span><br><span class="line">        <span class="built_in">unionset</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(++cnt==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;orz&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><p>给出一个有向图，请输出从某一点出发到所有点的最短路径长度。</p><p><strong>输入格式：</strong></p><p>第一行包含三个整数N、M、S，分别表示点的个数、有向边的个数、出发点的编号。</p><p>接下来M行每行包含三个整数Fi、Gi、Wi，分别表示第i条有向边的出发点、目标点和长度。</p><p><strong>输出格式：</strong></p><p>一行，包含N个用空格分隔的整数，其中第i个整数表示从点S出发到点i的最短路径长度（若S=i则最短路径长度为0，若从点S无法到达点i，则最短路径长度为2147483647）</p><p>$SPFA$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 500010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,dis[MAXN];</span><br><span class="line"><span class="type">bool</span> inq[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> v,w,next;&#125;edge[MAXM];</span><br><span class="line"><span class="type">int</span> tot,head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    edge[++tot].v=y;</span><br><span class="line">    edge[tot].w=z;</span><br><span class="line">    edge[tot].next=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; qwq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=INF;</span><br><span class="line">    </span><br><span class="line">    qwq.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;inq[s]=<span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!qwq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=qwq.<span class="built_in">front</span>();</span><br><span class="line">        qwq.<span class="built_in">pop</span>(); inq[x]=<span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=edge[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[y]&gt;dis[x]+edge[i].w)&#123;</span><br><span class="line">                dis[y]=dis[x]+edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[y])&#123;qwq.<span class="built_in">push</span>(y);inq[y]=<span class="literal">true</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        <span class="built_in">addedge</span>(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">if</span>(s==i)<span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$Dijkstra$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 200010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF =<span class="number">2147483647</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,dis[MAXN];</span><br><span class="line"><span class="type">bool</span> done[MAXN];</span><br><span class="line"><span class="type">int</span> tot,head[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> v,w,next;&#125;edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot].v=y;</span><br><span class="line">    edge[tot].w=z;</span><br><span class="line">    edge[tot].next=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,dist;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; v)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dist&gt;v.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; qwq;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=INF;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    qwq.<span class="built_in">push</span>((node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!qwq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node front=qwq.<span class="built_in">top</span>(); qwq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u=front.u,dist=front.dist;</span><br><span class="line">        <span class="keyword">if</span>(done[u])<span class="keyword">continue</span>;</span><br><span class="line">        done[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=edge[i].v,z=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[u]+z&lt;dis[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=dis[u]+z;</span><br><span class="line">                qwq.<span class="built_in">push</span>((node)&#123;y,dis[y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        <span class="built_in">addedge</span>(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>已知一个数列，你需要进行下面两种操作：</p><p>1.将某一个数加上x</p><p>2.求出某区间每一个数的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> c[MAXN],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        s+=c[i];</span><br><span class="line">        i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        c[i]+=value;</span><br><span class="line">        i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        <span class="built_in">update</span>(i,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;flag,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>) <span class="built_in">update</span>(x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(y)-<span class="built_in">sum</span>(x<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知一个数列，你需要进行下面两种操作：</p><p>1.将某区间每一个数数加上x</p><p>2.求出某一个数的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> c[MAXN],n,m,pre,now;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        s+=c[i];</span><br><span class="line">        i-=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        c[i]+=value;</span><br><span class="line">        i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;now);</span><br><span class="line">        <span class="built_in">update</span>(i,now-pre);</span><br><span class="line">        pre=now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;flag,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;y,&amp;k);</span><br><span class="line">            <span class="built_in">update</span>(x,k);<span class="built_in">update</span>(y+<span class="number">1</span>,-k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = MAXN<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> max0,n,m,tot,head[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN][<span class="number">25</span>],dep[MAXN],s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> v,next;&#125;edge[MAXM&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot].v=y;</span><br><span class="line">    edge[tot].next=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lcainit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=max0;i++)</span><br><span class="line">    <span class="keyword">if</span>(fa[x][i<span class="number">-1</span>])fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(y!=fa[x][<span class="number">0</span>])&#123;</span><br><span class="line">            fa[y][<span class="number">0</span>]=x;</span><br><span class="line">            dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">lcainit</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="type">int</span> delta=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;=max0;x++)</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;x)&amp;delta)u=fa[u][x];</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=max0;x&gt;=<span class="number">0</span>;x--)</span><br><span class="line">    <span class="keyword">if</span>(fa[u][x]!=fa[v][x])&#123;</span><br><span class="line">        u=fa[u][x];</span><br><span class="line">        v=fa[v][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    max0=(<span class="type">int</span>)(<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>))+<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">addedge</span>(x,y);<span class="built_in">addedge</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lcainit</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="强连通分量缩点"><a href="#强连通分量缩点" class="headerlink" title="强连通分量缩点"></a>强连通分量缩点</h2><p>题目描述：<a href="https://www.luogu.org/problemnew/show/P3387">https://www.luogu.org/problemnew/show/P3387</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span>+<span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> v,next;&#125;;</span><br><span class="line">Edge edge[maxm],edge2[maxm];</span><br><span class="line"><span class="type">int</span> head[maxn],w[maxn],dfn[maxn],low[maxn],stac[maxn],color[maxn];</span><br><span class="line"><span class="type">int</span> n,m,tot,num,top,cnt,ans;</span><br><span class="line"><span class="type">int</span> head2[maxn],W[maxn],tot2,sum[maxn];</span><br><span class="line"><span class="type">bool</span> ins[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++tot].v=y;</span><br><span class="line">    edge[tot].next=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edge2[++tot2].v=y;</span><br><span class="line">    edge2[tot2].next=head2[x];</span><br><span class="line">    head2[x]=tot2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">addedge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum[x])<span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head2[x];i;i=edge2[i].next)&#123;</span><br><span class="line">        temp=<span class="built_in">MAX</span>(temp,<span class="built_in">dfs</span>(edge2[i].v));</span><br><span class="line">    &#125;</span><br><span class="line">    sum[x]=W[x]+temp;</span><br><span class="line">    <span class="keyword">return</span> sum[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++num;</span><br><span class="line">    stac[++top]=x; ins[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">MIN</span>(low[x],low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[y])&#123;</span><br><span class="line">            low[x]=<span class="built_in">MIN</span>(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">        ++cnt; <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=stac[top--]; ins[y]=<span class="literal">false</span>;</span><br><span class="line">            color[y]=cnt;</span><br><span class="line">            W[cnt]+=w[y];</span><br><span class="line">        &#125;<span class="keyword">while</span>(x!=y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">input</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=edge[i].v;</span><br><span class="line">            <span class="keyword">if</span>(color[x]!=color[y])&#123;</span><br><span class="line">                <span class="built_in">addedge2</span>(color[x],color[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!sum[i])&#123;</span><br><span class="line">            ans=<span class="built_in">MAX</span>(ans,<span class="built_in">dfs</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非压位高精"><a href="#非压位高精" class="headerlink" title="非压位高精"></a>非压位高精</h2><p>虽然重载的运算符两边数据类型都是Bigint，但因为自动强制转换，所以用[Bigint] * [int]也不会错。</p><p>在大数除int、大数对int取余时，效率不及专门功能的函数</p><p>参考：CSDN用户 代号4101</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXLEN = <span class="number">1000</span>;  <span class="comment">//最长的数字长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bigint</span>&#123;</span><br><span class="line">    <span class="type">int</span> d[MAXLEN],len;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(len&gt;<span class="number">1</span>&amp;&amp;!d[len<span class="number">-1</span>])len--;&#125; <span class="comment">//去前导0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Bigint</span>()&#123;<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));len=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="built_in">Bigint</span>(<span class="type">int</span> num)&#123;*<span class="keyword">this</span>=num;&#125;</span><br><span class="line">    <span class="built_in">Bigint</span>(<span class="type">char</span>* num)&#123;*<span class="keyword">this</span>=num;&#125;</span><br><span class="line"></span><br><span class="line">    Bigint <span class="keyword">operator</span> = (<span class="type">const</span> <span class="type">char</span>* num)&#123;</span><br><span class="line">        len=<span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)d[i]=num[len<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bigint <span class="keyword">operator</span> = (<span class="type">int</span> num)&#123;</span><br><span class="line">        <span class="type">char</span> s[MAXLEN];</span><br><span class="line">        <span class="built_in">sprintf</span>(s,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">        *<span class="keyword">this</span>=s;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bigint <span class="keyword">operator</span> + (<span class="type">const</span> Bigint&amp; b)&#123; <span class="comment">//只能大数加小数</span></span><br><span class="line">        Bigint c=*<span class="keyword">this</span>; <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;b.len;i++)&#123;</span><br><span class="line">            c.d[i]+=b.d[i];</span><br><span class="line">            <span class="keyword">if</span>(c.d[i]&gt;<span class="number">9</span>)c.d[i]%=<span class="number">10</span>,c.d[i+<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c.d[i]&gt;<span class="number">9</span>)c.d[i++]%=<span class="number">10</span>,c.d[i]++;</span><br><span class="line">        c.len=<span class="built_in">MAX</span>(len,b.len);</span><br><span class="line">        <span class="keyword">if</span>(c.d[i]&amp;&amp;c.len&lt;=i)c.len=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bigint <span class="keyword">operator</span> - (<span class="type">const</span> Bigint&amp; b)&#123; <span class="comment">//不能用小数减大数</span></span><br><span class="line">        Bigint c=*<span class="keyword">this</span>; <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;b.len;i++)&#123;</span><br><span class="line">            c.d[i]-=b.d[i];</span><br><span class="line">            <span class="keyword">if</span>(c.d[i]&lt;<span class="number">0</span>)c.d[i]+=<span class="number">10</span>,c.d[i+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c.d[i]&lt;<span class="number">0</span>)c.d[i++]+=<span class="number">10</span>,c.d[i]--;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Bigint <span class="keyword">operator</span> * (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j; Bigint c;</span><br><span class="line">        c.len=len+b.len;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;b.len;j++)</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">                c.d[i+j]+=d[i]*b.d[j];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;c.len<span class="number">-1</span>;i++)</span><br><span class="line">            c.d[i+<span class="number">1</span>]+=c.d[i]/<span class="number">10</span>,c.d[i]%=<span class="number">10</span>;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bigint <span class="keyword">operator</span> / (<span class="type">const</span> Bigint&amp; b)&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        Bigint c=*<span class="keyword">this</span>,a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            a=a*<span class="number">10</span>+d[i];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)<span class="keyword">if</span>(a&lt;b*(j+<span class="number">1</span>))<span class="keyword">break</span>;</span><br><span class="line">            c.d[i]=j;</span><br><span class="line">            a=a-b*j;</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bigint <span class="keyword">operator</span> % (<span class="type">const</span> Bigint&amp; b)&#123;</span><br><span class="line">        <span class="type">int</span> i,j; Bigint a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            a=a*<span class="number">10</span>+d[i];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)<span class="keyword">if</span>(a&lt;b*(j+<span class="number">1</span>))<span class="keyword">break</span>;</span><br><span class="line">            a=a-b*j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bigint <span class="keyword">operator</span> += (<span class="type">const</span> Bigint&amp; b)&#123;</span><br><span class="line">        *<span class="keyword">this</span>=*<span class="keyword">this</span>+b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=b.len)<span class="keyword">return</span> len&lt;b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(d[i]!=b.d[i])<span class="keyword">return</span> d[i]&lt;b.d[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> b&lt;*<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;= (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> !(b&lt;*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt;= (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span>&lt;b);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> b&lt;*<span class="keyword">this</span>||*<span class="keyword">this</span>&lt;b;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> !(b&lt;*<span class="keyword">this</span>)&amp;&amp;!(b&gt;*<span class="keyword">this</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="type">char</span> s[MAXLEN]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)s[len<span class="number">-1</span>-i]=d[i]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in,Bigint&amp; x)&#123;</span><br><span class="line">    string s; in&gt;&gt;s;</span><br><span class="line">    x=s.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,<span class="type">const</span> Bigint&amp; x)&#123;</span><br><span class="line">    out&lt;&lt;x.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     <span class="comment">//just an example...</span></span><br><span class="line">    Bigint s=<span class="number">0</span>,t;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.len==<span class="number">1</span>&amp;&amp;!t.d[<span class="number">0</span>])<span class="keyword">break</span>;</span><br><span class="line">        s=s+t;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="压位高精"><a href="#压位高精" class="headerlink" title="压位高精"></a>压位高精</h2><p>题面：<a href="https://www.luogu.com.cn/problem/P2152">https://www.luogu.com.cn/problem/P2152</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> power_10[]=&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">1000</span>,<span class="number">10000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bigint</span> &#123;</span><br><span class="line">    LL a[N],len;</span><br><span class="line">    <span class="built_in">Bigint</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a)),len=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(len&gt;<span class="number">1</span>&amp;&amp;!a[len<span class="number">-1</span>])len--;&#125; <span class="comment">//去前导0</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x)a[len++]=x%base,x/=base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> s[N];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        len=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=<span class="built_in">strlen</span>(s),t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rint i=n<span class="number">-1</span>;~i;--i,++t) &#123;</span><br><span class="line">            a[len<span class="number">-1</span>]+=(s[i]-<span class="string">&#x27;0&#x27;</span>)*power_10[t];</span><br><span class="line">            <span class="keyword">if</span>(t+<span class="number">1</span>==limit)t=<span class="number">-1</span>,++len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!t)--len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c=<span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a[len<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(rint i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)<span class="built_in">printf</span>(<span class="string">&quot;%0*lld&quot;</span>,limit,a[i]);</span><br><span class="line">        <span class="keyword">if</span>(~c)<span class="built_in">putchar</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Bigint</span>(<span class="type">int</span> num)&#123;*<span class="keyword">this</span>=num;&#125;</span><br><span class="line">    <span class="built_in">Bigint</span>(<span class="type">char</span>* num)&#123;*<span class="keyword">this</span>=num;&#125;</span><br><span class="line">    Bigint <span class="keyword">operator</span> = (<span class="type">const</span> <span class="type">char</span>* num)&#123;</span><br><span class="line">        len=<span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)a[i]=num[len<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Bigint <span class="keyword">operator</span> = (<span class="type">int</span> num)&#123;</span><br><span class="line">        <span class="type">char</span> s[N];</span><br><span class="line">        <span class="built_in">sprintf</span>(s,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">        *<span class="keyword">this</span>=s;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=b.len)<span class="keyword">return</span> len&lt;b.len;</span><br><span class="line">        <span class="keyword">for</span>(rint i=len<span class="number">-1</span>;~i;i--)</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=b.a[i])<span class="keyword">return</span> a[i]&lt;b.a[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> b&lt;*<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;= (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> !(b&lt;*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt;= (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span>&lt;b);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> b&lt;*<span class="keyword">this</span>||*<span class="keyword">this</span>&lt;b;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Bigint&amp; b)<span class="type">const</span>&#123;<span class="keyword">return</span> !(b&lt;*<span class="keyword">this</span>)&amp;&amp;!(b&gt;*<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Bigint <span class="keyword">operator</span> + (<span class="type">const</span> Bigint &amp;a,<span class="type">const</span> Bigint &amp;b) &#123;</span><br><span class="line">    Bigint c;<span class="type">int</span> mx=<span class="built_in">MAX</span>(a.len,b.len);c.len=mx;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">0</span>;i&lt;mx;++i)c.a[i]=a.a[i]+b.a[i];</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">0</span>;i&lt;mx;++i)<span class="keyword">if</span>(c.a[i]&gt;=base)++c.a[i+<span class="number">1</span>],c.a[i]-=base;</span><br><span class="line">    <span class="keyword">if</span>(c.a[c.len])++c.len;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">Bigint <span class="keyword">operator</span> - (<span class="type">const</span> Bigint &amp;a,<span class="type">const</span> Bigint &amp;b) &#123;</span><br><span class="line">    Bigint c;<span class="type">int</span> mx=a.len;c.len=mx;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">0</span>;i&lt;mx;++i)c.a[i]=a.a[i]-b.a[i];</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">0</span>;i&lt;mx;++i)<span class="keyword">if</span>(c.a[i]&lt;<span class="number">0</span>)--c.a[i+<span class="number">1</span>],c.a[i]+=base;</span><br><span class="line">    <span class="keyword">while</span>(c.len&amp;&amp;!c.a[c.len<span class="number">-1</span>])--c.len;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">Bigint <span class="keyword">operator</span> * (<span class="type">const</span> Bigint &amp;a,<span class="type">const</span> Bigint &amp;b) &#123;</span><br><span class="line">    Bigint c;<span class="type">int</span> mx=a.len+b.len<span class="number">-1</span>;c.len=mx;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">0</span>,mxa=a.len;i&lt;mxa;++i)</span><br><span class="line">        <span class="keyword">for</span>(rint j=<span class="number">0</span>,mxb=b.len;j&lt;mxb;++j) &#123;</span><br><span class="line">            c.a[i+j]+=a.a[i]*b.a[j];</span><br><span class="line">            <span class="keyword">if</span>(c.a[i+j]&gt;=base)c.a[i+j+<span class="number">1</span>]+=c.a[i+j]/base,c.a[i+j]%=base;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(c.a[c.len])++c.len;</span><br><span class="line">    <span class="keyword">return</span> c; </span><br><span class="line">&#125;</span><br><span class="line">Bigint <span class="keyword">operator</span> / (<span class="type">const</span> Bigint &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b) &#123;</span><br><span class="line">    Bigint c;<span class="type">int</span> mx=a.len;</span><br><span class="line">    LL now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rint i=mx<span class="number">-1</span>,s=<span class="number">0</span>;~i;--i) &#123;</span><br><span class="line">        now=now*base+a.a[i];</span><br><span class="line">        <span class="keyword">if</span>(now/b)s=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!s)<span class="keyword">continue</span>;</span><br><span class="line">        c.a[c.len++]=now/b;</span><br><span class="line">        now%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(c.a,c.a+c.len);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Bigint <span class="title">biggcd</span><span class="params">(Bigint x,Bigint y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> xcnt2=<span class="number">0</span>, ycnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!(x.a[<span class="number">0</span>]&amp;<span class="number">1</span>))&#123;xcnt2++; x=x/<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(!(y.a[<span class="number">0</span>]&amp;<span class="number">1</span>))&#123;ycnt2++; y=y/<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="type">int</span> z=<span class="built_in">MIN</span>(xcnt2,ycnt2);</span><br><span class="line">    <span class="keyword">while</span>(x!=y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;<span class="built_in">swap</span>(x,y);&#125;</span><br><span class="line">        x=x-y;</span><br><span class="line">        <span class="keyword">while</span>(!(x.a[<span class="number">0</span>]&amp;<span class="number">1</span>))&#123;x=x/<span class="number">2</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Bigint temp = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(z--)&#123;x=x*temp;&#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Bigint a,b;</span><br><span class="line">    a.<span class="built_in">read</span>(); b.<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">biggcd</span>(a,b).<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h2><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3386">https://www.luogu.com.cn/problem/P3386</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxvertex=<span class="number">503</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxedge=<span class="number">5e4</span>+<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> tot,n,m,e,ans;</span><br><span class="line"><span class="type">int</span> head[maxvertex],match[maxvertex&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> v,next;&#125;edge[maxedge];</span><br><span class="line"><span class="type">bool</span> vis[maxvertex&gt;&gt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edge[++tot].v=y;</span><br><span class="line">    edge[tot].next=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x],y;i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[y=edge[i].v])&#123;</span><br><span class="line">            vis[y]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>((!match[y]) || <span class="built_in">dfs</span>(match[y]))&#123;</span><br><span class="line">                match[y]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;e);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=e;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">addedge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i))&#123;ans++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要就是整理一下常见的算法模板，个人使用。&lt;/p&gt;
&lt;h2 id=&quot;线性筛素数&quot;&gt;&lt;a href=&quot;#线性筛素数&quot; class=&quot;headerlink&quot; title=&quot;线性筛素数&quot;&gt;&lt;/a&gt;线性筛素数&lt;/h2&gt;&lt;p&gt;给定一个范围N，你需要处理M个某数字是否为质数的询问（每个</summary>
      
    
    
    
    <category term="笔记" scheme="https://loveofpeach.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://loveofpeach.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode407</title>
    <link href="https://loveofpeach.github.io/posts/5f46c25d.html"/>
    <id>https://loveofpeach.github.io/posts/5f46c25d.html</id>
    <published>2022-09-27T03:33:04.000Z</published>
    <updated>2023-01-22T15:04:29.731Z</updated>
    
    <content type="html"><![CDATA[<p>正经解法比较复杂，这里贴出一个相对简单的解法。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= m,n &lt;= 200</span><br><span class="line">0 &lt;= heightMap[i][j] &lt;= 2*10^4</span><br></pre></td></tr></table></figure><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><img src="https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg" alt="8-1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p><img src="https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg" alt="8-2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先需要明确一点，该题中不存在“空洞”，否则数据不足以描述房屋的状态。即不存在以下（左视图）情况：</p><p><img src="https://s2.loli.net/2022/09/27/m8bp5xUGv7jSaL2.png" alt="8-3.png"></p><p>引理：沿水平方向任切一刀去除下层后，接水体积只会减少被切除部分中水的体积（若存在）。</p><p>解释：考虑使用一个锋利的铁板去切，切后仍用铁板托住上层，则上下两层的水均不会流出。</p><p>由引理，问题规模缩小。</p><h3 id="代码实现（无优化）"><a href="#代码实现（无优化）" class="headerlink" title="代码实现（无优化）"></a>代码实现（无优化）</h3><p>记最高高度为<code>MAXH</code>，从第一层（从上往下数）开始切，<code>for k 1 to MAXH</code>，则切下来的上层可记为<code>MAX(0,a[i][j]-MAXH+k)</code>，对新的矩阵dfs元素为零的连通块，同时记录连通块大小。注意若连通块通向边界，则水流出，该连通块作废。遍历完第k层后k++，继续计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">203</span>][<span class="number">203</span>];</span><br><span class="line"><span class="type">int</span> MAXH=<span class="number">-1</span>,m,n,ans;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">203</span>*<span class="number">203</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mmap</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="number">203</span>*(x<span class="number">-1</span>)+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            MAXH=<span class="built_in">MAX</span>(MAXH,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">bool</span> _myflag,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    vis[<span class="built_in">mmap</span>(x,y)]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">1</span>)||(x==m)||(y==<span class="number">1</span>)||(y==n))&#123;</span><br><span class="line">        _myflag=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;<span class="number">4</span>;p++)&#123;</span><br><span class="line">        <span class="type">int</span> nx=x+dir[p][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ny=y+dir[p][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(vis[<span class="built_in">mmap</span>(nx,ny)]||(nx&lt;<span class="number">1</span>)||(nx&gt;m)||(ny&lt;<span class="number">1</span>)||(ny&gt;n))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">MAX</span>(<span class="number">0</span>,a[nx][ny]-MAXH+k))<span class="keyword">continue</span>;</span><br><span class="line">        cnt+=<span class="built_in">dfs</span>(nx,ny,_myflag,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!_myflag)cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">input</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=MAXH;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">MAX</span>(<span class="number">0</span>,a[i][j]-MAXH+k))vis[<span class="built_in">mmap</span>(i,j)]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(vis[<span class="built_in">mmap</span>(i,j)])<span class="keyword">continue</span>;</span><br><span class="line">                ans+=<span class="built_in">dfs</span>(i,j,<span class="literal">true</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码实现（优化后）"><a href="#代码实现（优化后）" class="headerlink" title="代码实现（优化后）"></a>代码实现（优化后）</h3><p>上面的代码中，首次找到某一层的全部连通块后，记录连通块的位置，不再进行dfs，改为查询已记录位置下方是否有零。</p><p>该改进的原理是：因不存在空洞，下一层的零元连通块是上层零元连通块的子集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">203</span>][<span class="number">203</span>],pos[<span class="number">202</span>*<span class="number">202</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> MAXH=<span class="number">-1</span>,m,n,ans,cnt;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">203</span>*<span class="number">203</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mmap</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="number">203</span>*(x<span class="number">-1</span>)+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            MAXH=<span class="built_in">MAX</span>(MAXH,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k,<span class="type">bool</span> s)</span></span>&#123;</span><br><span class="line">    vis[<span class="built_in">mmap</span>(x,y)]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(s)&#123;</span><br><span class="line">        pos[++cnt][<span class="number">0</span>]=x;</span><br><span class="line">        pos[cnt][<span class="number">1</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;<span class="number">4</span>;p++)&#123;</span><br><span class="line">        <span class="type">int</span> nx=x+dir[p][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ny=y+dir[p][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(vis[<span class="built_in">mmap</span>(nx,ny)]||(nx&lt;<span class="number">1</span>)||(nx&gt;m)||(ny&lt;<span class="number">1</span>)||(ny&gt;n))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">MAX</span>(<span class="number">0</span>,a[nx][ny]-MAXH+k))<span class="keyword">continue</span>;</span><br><span class="line">        cnt+=<span class="built_in">dfs</span>(nx,ny,k,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">input</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=MAXH;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> ha=<span class="number">1</span>;ha&lt;=cnt;ha++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[pos[ha][<span class="number">0</span>]][pos[ha][<span class="number">1</span>]]-MAXH+k&lt;=<span class="number">0</span>)ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">MAX</span>(<span class="number">0</span>,a[<span class="number">1</span>][j]-MAXH+k))vis[<span class="built_in">mmap</span>(<span class="number">1</span>,j)]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[<span class="built_in">mmap</span>(<span class="number">1</span>,j)])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>,j,k,<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">MAX</span>(<span class="number">0</span>,a[m][j]-MAXH+k))vis[<span class="built_in">mmap</span>(m,j)]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[<span class="built_in">mmap</span>(m,j)])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(m,j,k,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">MAX</span>(<span class="number">0</span>,a[i][<span class="number">1</span>]-MAXH+k))vis[<span class="built_in">mmap</span>(i,<span class="number">1</span>)]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[<span class="built_in">mmap</span>(i,<span class="number">1</span>)])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i,<span class="number">1</span>,k,<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">MAX</span>(<span class="number">0</span>,a[i][n]-MAXH+k))vis[<span class="built_in">mmap</span>(i,n)]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[<span class="built_in">mmap</span>(i,n)])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i,n,k,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">MAX</span>(<span class="number">0</span>,a[i][j]-MAXH+k))vis[<span class="built_in">mmap</span>(i,j)]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(vis[<span class="built_in">mmap</span>(i,j)])<span class="keyword">continue</span>;</span><br><span class="line">                ans+=<span class="built_in">dfs</span>(i,j,k,<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ans)<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;正经解法比较复杂，这里贴出一个相对简单的解法。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高</summary>
      
    
    
    
    <category term="做题" scheme="https://loveofpeach.github.io/categories/%E5%81%9A%E9%A2%98/"/>
    
    
    <category term="算法" scheme="https://loveofpeach.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>new918</title>
    <link href="https://loveofpeach.github.io/posts/e1e3cea2.html"/>
    <id>https://loveofpeach.github.io/posts/e1e3cea2.html</id>
    <published>2022-09-18T15:01:30.000Z</published>
    <updated>2022-12-28T04:18:39.595Z</updated>
    
    <content type="html"><![CDATA[<p>呵，今夜无眠。</p><p><img src="https://s2.loli.net/2022/12/28/EiYv8nyIVgSBHhu.jpg" alt="7-1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;呵，今夜无眠。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/12/28/EiYv8nyIVgSBHhu.jpg&quot; alt=&quot;7-1.jpg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂" scheme="https://loveofpeach.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="想法" scheme="https://loveofpeach.github.io/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
</feed>
